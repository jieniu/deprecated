<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[我的阅读理解升级之路]]></title>
      <url>%2F2017%2F02%2F03%2Freally-read%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，甚至无需保留以上版权声明 自从读大学以来，我开始喜欢上了阅读。众所周知，在大学课堂上几乎是学不到什么东西的，但一般的，学校会规定过了四级才能拿到学位证，除了这个，我还需要把专业技能学好，才能在毕业后找到一份满意的工作。为了达到这两个目的，我必须逼着自己去图书馆自习。当然现在互联网相比过去10年有了长足的进步，你完全可以在网上进行学习。 正因为经常去图书馆，发现自己竟然培养了自习的习惯，也让我体会到了成长的乐趣，且这个习惯一直保持至今，我认为，这一点是我在大学中学到的最重要的能力。 以前都是读一些自己感兴趣的，或者专业上需要的书籍，亦或是别人推荐的比较不错的书，我也经常去豆瓣上找一些高分书籍拿来看，那时的我，对于阅读的理解是 在工作之余，保持一定的持续阅读习惯，才不会被淘汰，反而还可以帮助自己稳步上升 换句话说，即是’读总比不读好’，但这很难让我看到一个终点，或让自己有阶段性的目标，当时所谓的目标就是：读完一本，再读一本。 读非专业书籍，不像我学的计算机专业类书籍那样——每读完一本后有会有明显的提升，它们很难在我读完之后给自己带来变化，记忆中偶尔也会读到一些好书，比如《少有人走的路》、《拆破思维的墙》等，这些书能够帮助我们改变自己的行为，记得当时读完后，我还打鸡血似的向朋友推荐，说自己今后要怎样怎样，朋友很淡定的回了一句：“这本书我也读过，刚读完的时候是有变化，但过了一段时间后又会打回原形”。 果然不出朋友所料，我现在仅仅记得《拆破思维的墙》中有指导我们要投资自己，即便用部分工资去培训也不为过的内容。但自从读完书到现在的几年时间里，我从来都没有一次按照书中的方法论实践过，如果你也是这样，我只能说： 你并不孤独。 这种阅读状态保持了很长一段时间，但毕竟自己生活在互联网中，经常看到很多人在网上晒书单，晒总结，而且也不乏一些牛人，我发现他们的共同点就是有很大的阅读量，所以在网上能够厚积薄发，聚集大量的粉丝，于是我得出一个结论：我现在成长这么缓慢，应该是自己积累不够多，等到我积累到一定程度，自然拥有和他们一样的能力。于是我的目标转变为 提升自己的阅读量 制定了这样的目标后，就经常会对阅读方法类的文章或书籍特别感兴趣，只要一看到类似的文章，就一定要拿来反复阅读，想将这些方法运用到实践中。以下是我最后一次修订的阅读方法： 制定阅读计划，例如8小时阅读一本书，分次进行，每次读1-2小时 通读，花10%时间，了解作者的论点 细度，花80%的时间，抓住重要论点和论据 做笔记，花10%的时间，用自己的话记录书中的论点 这样的阅读方法看上去非常理想，但实践过程中发现它很难操作，究其原因是因为要驾驭这种方法，需要有很强的时间感知能力，而在没有这样的能力之前，几乎是很难在规定的时间内完成一本书的，即便完成，也是囫囵吞枣，达不到真正的阅读效果。最终的结论是这种方法不适合我，不过我用它来读相对短很多的文章，还是蛮有效果的。 再次总结那段时间的非虚构非专业书籍的阅读方式，即是“为了读而读”，而并没有意识到 不能实际改变自己行为或生活的书，是没有用的 现在回想起来真的是非常可怕，“浪费”了相当多的时间。 罗辑思维引领了一个时代的“认知升级”，我从去年6月重新开始关注它的公众号和得到App，然后通过得到，我订阅了李笑来的专栏，短短半年的时间，我已经成为了他的铁杆粉丝，读他的文章，能给我带来很大的帮助。其实早在几年前，我就知道笑来老师了，并收藏了他的《普通人的当众讲话技能》 这本书的链接，但是从收藏那一刻开始，我再也没有打开过这个链接，也没有再关注他后续的动态，现在想起来，以我今天对他的崇拜程度，没有持续关注他并向他学习这件事情，真是一大遗憾。 这里要说下笑来老师的两个理论，它们对我阅读的帮助非常大 知识改变命运，而其中很重要的手段就是阅读 你一定要只字不差的阅读 第一个理论我想没有人会不知道，但很多人即便知道，也不一定相信这个理论的真实性，所以很多人一离开学校，就开始停止阅读了，因为他们觉得还有更靠谱的方法可以让他们生活的更好。而我以前对这个理论也抱有将信将疑的态度，只知道读总比不读好，不确定它真的就是唯一的可以改变人生的方法。 而我现在对它却坚信不疑，因为互联网连接能力的增强，让我看到了包括笑来老师在内的其他很多超级大V，都一直在践行这套理论，结论真的是应验了那句话： 最可怕的不是很多人比你牛，而是比你牛的人比你还努力。 第一次看到”只字不差的阅读”这几个字时，觉得这几个字简直是给自己带来了福音，心想以后再也不用花心思去找其他的阅读方法了，毕竟自己本来就没有像泛读或跳读之类的能力。可这并不代表我就擅长”只字不差的阅读”，相反，我理解的”只字不差”只是表面上的，经过了一段时间的反复思考，我发现只字不差的阅读并没有那么简单，它包含了三个层次的意思，分别是 理解：理解作者的意图 内化：将好的内容变成自己的 践行：反复思考这些内容可以用到的地方，并学以致用 了解了这三层意思之后，读书的时候，真的可以比以前看到得更多，相反，在没有领悟到这三个层次之前，阅读只是停留在表面上，除了看到的内容少的可怜外，也很容易忘记看过的内容。而这三点中，后两点正是倒逼第一点有效手段，它们会时刻提醒自己多理解一点，多看到一点，会让自己主动去思考作者说的是对还是错，如果是对的，这样的内容还可以用在哪里，是否可以帮助自己解决某些问题等。所以看到的越多，以后可用的东西也会越多。 能够想到这些也是因为前两段时间我在听新生大学的写作课时，笑来老师讲到写作中的素材收集部分，他会把读到的故事、论证方式等好的内容摘抄下来，制作成小卡片，在小卡片上标记这些素材可以用到的场景，日积月累，就形成了自己的资料库，当写作或准备演讲时，需要素材，就在大脑中检索素材关键字对应的小卡片（换句话说，只需要记小卡片的关键字即可），然后直接找到小卡片并引用其中的内容即可。 其实几个月前，我读过李敖的读书方法，李敖为了把好的知识搜集起来，会把这部分内容从书中剪掉，如果一页纸上正反面都有他需要的内容，他会同时买两本书，裁剪后的纸张会粘在自己的文件夹中，文件夹是精心进行了分类整理的，类别也非常细，如果他需要去找某个特定的素材，直接去找对应的分类文件夹即可。所以李敖的知识量不仅很深，而且巨广，什么都可以谈，而且什么都可以谈的头头是道。你会发现，李笑来和李敖两位大师的方法有着异曲同工之妙，经过一次整理的过程就是内化的过程，内化得越好，以后使用的时候就越方便，越方便，就更容易被使用，从而促进了第三步的践行。 自己能理解到目前的程度并不容易，至少经过了半年的时间，而一旦理解，你会感觉自己的眼睛被擦亮了一样，看到的东西比以前会清楚太多。 还有，今天读了一篇文章，里面提到了在阅读的时候，如何进高效的内化，作者介绍了一个记忆宫殿的概念，即将新的知识和大脑中的已存在的知识进行匹配，如果能有所联系，那么我们更容易理解书中的内容，因为大脑非常善于做模式匹配的事情。 我觉得也非常有道理，但局限在于，如果是全新的知识，大脑中没有对应的模式，就很难做到模式匹配了，或者在一个你不熟悉的领域，很难靠自己就知道哪些知识是浅显的，哪些是精尖的，还是需要相应领域的牛人的指引才行。所以，没有绝对完美的方法，适合自己的才是最好的，以下是我收集的能够帮助我更好内化的方法： 通过模式匹配进行记忆（记忆宫殿） 带着问题读书、学习，印象更深刻 反复练习，掌握新技能的最少必要知识，掌握后马上应用 把真正有用的东西摘抄下来，对应于应用场景，建立自己的素材库 读不懂，反复阅读，直到读懂为止]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一月结束了]]></title>
      <url>%2F2017%2F02%2F01%2F201701%2F</url>
      <content type="text"><![CDATA[2017年1月总结紧急不重要 42% 312.5小时 睡觉 32% 238小时 过年、拜年 3.6% 26.8小时 吃饭 3.3% 通勤 1%…… 学习（重要不紧急） 31.4% 233.6小时 英语朗读/阅读 9.8% 72小时 四本原版书都未完成 ruby on rails + react 6.4% 47.6小时 rails101react + redux 入门 听有声书/听分享 5.1% 37.9小时 写作 3.7% 27.53小时 完成5篇文章 《得到》 2.7% 20.1小时 阅读 2.6%…… 工作 21.2% 157.73小时 coding 12% 89.3小时 用go写raw tcp框架timeout serviceid servicerobot service meeting 2.6% 19.3小时 docker / saltstack / elk 文档阅读 1.7% 架构设计 1.7% 运维工作 1.1% 休息（不重要不紧急） 4.4% 32.74小时运动 0.3% 2.23小时一句话总结时间都挤出来了，效率还需要提升，才能增加输入和输出的产能。 版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，甚至无需保留以上版权声明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一招获得早起技能]]></title>
      <url>%2F2017%2F01%2F30%2Fget-up-early%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，甚至无需保留以上版权声明 今天是大年初三，在此给大家拜个晚年，祝大家新年都有新的收获。 要说的是今年过年我都是6点起床的，目前我在武汉过年，要知道武汉的冬天是比深圳冷不少的。同时，早上起早床是我在今年需要培养的一个习惯，且我已经保持了快一个月。 去年我基本都是8点多才起床，算下来，如果今年每天6点起床，平白无故就比去年多出700多个小时，以每天工作6小时计算，即是多了100多个工作日，这何尝不是捡了一个巨大的便宜。 起早这件事，说起来简单，但我确实是斗争了好久才有所改善的，去年某个时候，为了能够起早，我专门去看了别人关于起早的文章，希望从中找到几条不二法门，帮助我实现这个目标，别人的经验中有几点也特别有印象： 关键在于早睡，每天保证6-8个小时的睡眠非常重要 上两个闹钟，一个放在床边，声音比较小，这样不会影响到他人，再上一个大闹钟，放在客厅，当床边的闹钟响起时，你需要去关闭客厅的闹钟，不然，一旦客厅闹钟的闹铃响起，则一定会让你旁边的老婆勃然大怒，想必为了避免这件事儿，你也不会再懒床了吧。 找一些志同道合的人，为他们叫早的同时，你也可以起个早床 …… 这些方法都很好，但我觉得仍然因人而异，对于我来说，我依然没有足够的动力去执行这几个方法。 又过了一段日子，差不多是2016年12月，我开始培养自己的起早习惯，且一开始还是失败了“无数次”，不过到目前为止，这个习惯大致养成，在这段时间内，我又是怎么突破自己的呢？ 首先，你一定要给自己一个充足的理由，我的理由其实很简单，就是我需要成长，而成长需要时间积累，这个时间最好是属于我一个人的，不会因为其他人或事情而受影响，于是自然就想到了早上，为了提醒自己，我经常会衡量起早的利和不起早的弊 起早的利：持续稳定的成长 不起早弊：无法持续稳定成长，经常被打断，焦虑，恶性循环 想到这里，我便没有理由不起早床了 充分的理由很重要，想法再好，在执行的时候还是会有所差异，所谓 Knowing is one thing, actually doing it is another thing entirly. ——《succeed, how we can reach our goals》 经过一段时间的实践，我发现其中最大的障碍，就是只想到了起早这件事的结果，且对于这个结果的发生过于乐观，而从未思考过执行过程中困难，这些困难可能包括： 冬天天气比较冷 天还是黑的，和想象中的“清晨的画面”有差异 觉得还早，再多睡5分钟 美梦还没做完呢，还想多做会 别人都还在睡呢，想和别人一样 枕边人的一句“再多睡会” 为了不起早床，自己制造出的1万个理由 由于早上意志力及其薄弱，任何一个理由都有可能把你击退到被窝里，一旦你回去，你会发现原来预想的多睡5分钟变成了多睡2小时。 所以，一定要意识到起早的困难，并做好防御的准备，在懒惰意识到来的时候，同时唤醒自己的意志力，用意志力将其打退，在这个过程中，我一般这样处理的 减少环境带来的影响，例如天冷时将厚衣服放在床头，一起来就很方便的穿上 告诉身边的人，自己在培养早起的习惯，不要在那时候引诱自己，且得到他们的理解 告诉自己，也就难受几秒钟，几秒后，精神不但不会差，反而还会更好 其中前两点是解决外界干扰，其实比较容易办到，而第三点才是我在无数次失败中总结出来的，用来战胜自我的法宝，对于我来说，这一招就可以击败我上面说的一万个懒床的理由。 总结： 起早就是捡便宜 起早并不容易 行动，总结自己的失败，找到“一招制胜”的方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vim最少必要知识]]></title>
      <url>%2F2017%2F01%2F27%2Fvim%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，甚至无需保留以上版权声明 一. Vim是什么都说程序员只用两种编辑器，一种是编辑器之神Vim，一种是神的编辑器Emacs，可现实生活中，我发现真正用这两种编辑器的人很少，所以我开始有点怀疑这句话的真实性。 刚毕业那会，我对实际的软件开发了解甚少，于是糊里糊涂的进入了服务器开发领域，现在回想起来真是觉得既幸运又后怕。幸运的是，在我完全不了解的情况下竟然选择了后端开发，后怕的是，既然不了解，就很可能选择到其他方向，而另一个选择可能会造就一个完全不同的人生轨迹。虽然从现在的眼光去看软件开发的每个方向，都非常有趣和有挑战，但服务器领域才是我最向往的地方，且它极大程度的满足了我的好奇心。不知道为什么，我对很古老的东西很感兴趣，服务器开发日常面对的是一个终端界面，没有图形化的丰富表现，只有常规的字符，让我着迷的肯定不是它的表现形式，更深层次的讲，它更接近于计算机最开始的样子，在这种环境下工作可以帮助我更容易的掌握机算机的原理和思想。 区别于Windows这样的操作系统，Unix/Linux系统的设计原则是简约（Kiss原则），可能有点违背直觉，大多数人认为Windows更为容易上手，确实如此，但这并不意味着它的设计就是简单的，使用起来就是高效的。而Unix不同，其中的每一个程序都只完成单一的功能，程序之间可以很容易的交互数据，这样，通过将不同程序进行任意组合，可以创造出任意的功能，既匹配了程序员这一创造性工作，又极大的提升了工作效率。试比较——在同一目录下，将所有jpg后缀转换为png后缀的操作——在哪个系统上操作更为方便。 Unix设计原则对于大多数程序员来说，是一种“信仰”，而Vim也是其中一个具备KISS原则的产品。 所谓程序员只用两种编辑器，我现在似乎明白为什么使用它们的程序员实际上并不多的原因了，这句话缺少了一个时间的维度，在过去，图形界面不发达，人们用计算机只能使用命令行，在命令行中也只能使用Vim或Emacs编辑器，而随着时代的变迁，人们更倾向于使用易于上手的图形化软件，他们希望速成，不愿意在编辑器上花成本，而逐渐忘却了Vim或Emacs。时至今日，这句话变成了： 程序员都用两种编辑器，大多数人使用图形化编辑器，少数人使用Vim或Emacs。 二. 我为什么使用Vim我为什么会选择Vim，一是因为Vim可以在所有操作系统及终端中使用，真正做到了“一招鲜，吃遍天”。学会了Vim，你再也不需要学习其他编辑器。 相反，如果你使用IDE的话，可能这辈子要学习很多编辑器，例如当你使用C/C++时，你可能会用VS/SourceInsignt/SublimeText等，当你使用Java时，你可能会换成Eclipse/Android Studio，而当你做前端开发时，你需要学习使用WebStorm/Atom等。同时，这些IDE都无法在终端中运行，这时你要编码和调试，需要跨越两个环境，效率极低，如果你想改变这种现状，你还得学习Vim。 而对于程序员来说，一个顺手的开发环境决定了他的开发效率和幸福指数，有时为了一个稳定又一致的开发环境，我会放弃公司的办公电脑，取而代之的是背一部几公斤重的笔记本来来回回。 二是Vim的效率很高，它会想尽一切办法将你的双手放在主键盘区，甚至不需要碰小键盘或鼠标，更深一层，为了达到相同的目的，它会让你尽可能减少按键次数。这样做都是为了让你更加专注，集中精力去完成当前的工作，而右手经常在鼠标和键盘之间来回切换，无疑是一种“打断”。 最后一个原因，使用Vim真的很酷，因为Vim学习曲线比较陡峭，即便对于程序员同学来说，它不好用，或是一头难以驯服的猛兽，所以在这种情况下，如果你可以把它运用自如，你拥有的就是别人从未有过的一种体验。 三. 至少要掌握的知识说Vim学习曲线陡峭，其实也是相对于其他编辑器来说的，其实也并没有多陡峭，下面主要从以5个概念，来谈一下Vim的最少必要知识，这是我平时使用Vim的过程中，总结出来的：对于一个新人，至少要知道哪些用法呢？ 模式 命令 窗口，Buffer 配置 插件 模式模式是Vim区别于其他编辑器的首要功能，它要解决的问题是“只使用键盘就可以完成所有工作”，你可以想象一下，当你在使用电脑时，克制自己不用鼠标或触控板时的感受：你也许会感觉非常无力吧。而当你在使用Vim时，这件事情不会给你带来任何不适，相反如果你适应了Vim的模式后，看到别人的右手在键盘和鼠标之间来回切换，你才会觉得那个人的效率和自己比起来是多么低效。 Vim中的三个模式分别是 普通模式normal 插入模式insert 可视模式visual 普通模式相对于插入模式，它用来控制光标移动、复制/粘贴文本、排版等，并将这些功能映射到指定的快捷键中，这样当你输入一个按键，它就会帮你完成以上功能。 &lt;Esc&gt;&lt;Esc&gt;按键帮你从其他模式切换到普通模式，所以当苹果在最新版的macbook pro中取消&lt;esc&gt;按键时，一大批Vimer第一个反应就是macbook pro不适合开发者，不过我觉得这应该不是什么大问题，在切换到Vim时，肯定会弹出相应的虚拟按键，只是手感上应该会差很多，但如果要追求更好的手感，我推荐你去外接一个机械键盘，真的不一样。 h/j/k/l这四个键在键盘的最中间，当你处于普通模式时，h/j/k/l这四个按键分别代表了光标向左/下/上/右移动一个字符，当然你完全不需进行刻意的记忆，打开电脑练习几次就习惯了。学会了这几个按键，你的手指再也不需要移动到小键盘上去了。 移动 ctrl+f/b/d/u这四个快捷键，可以帮助你翻页，实现光标在文件中快速移动。 ctrl+f：向下翻一页 ctrl+b：向上翻一页 ctrl+d：向上翻半页 ctrl+u：向下翻半页 移动 b/w/e/shift+^/shift+$普通模式下，h和l每次只能向左或向右移动一个字符，这无疑是非常慢的，下面几个快捷键，可以帮助你在行内快速移动 b：将光标移动到上一个单词的第一个字符 w：将光标移动到下一个单词的第一个字符 e：将光标移动到下一个单词的最后一个字符 shift+^：将光标移动到行首 shift+$：将光标移动到行尾 移动 f/F’a’在行内快速移动的“升级版”，单引号中的内容可以用任意字符代替，例如f’b’/F’b’ fa：将光标移到右边的第一个字符a上，继续按’;’（分号），可以延相同的方向找到下一个a，继续按’,’（逗号），可以延反方向找到下一个a Fa：将光标移到左边的第一个字符a上，继续按’;’（分号），可以延相同的方向找到下一个a，继续按’,’（逗号），可以延反方向找到下一个a 当你熟练使用这个快捷键，你就知道我为什么会说： Vim会尽量减少你敲键盘的次数 移动 H/M/L这几个快捷键，可以帮你把光标移动到屏幕的上方/中间/下方，注意是要打开大写锁定或按住shift H(high)：将光标移动到屏幕上方 M(middle)：将光标移动到屏幕中间 L(low)：将光标移动到屏幕下方 移动 [n]jk中括号中的n可以用任意数字代替，例如10j表示将光标向下移动10行，而10k则相反 [n]j：将光标向下移动n行 [n]k：将光标向上移动n行 移动 [n]G同[n]jk命令，[n]G命令会帮你把光标移动到指定的行数，例如100G，会将光标移动到文件的第100行 移动 gg/G这两个快捷键，会将光标移动到文档的第一行或最后一行 gg：将光标移动到文档的第一行 G：将光标移动到文档的最后一行 移动 zz这个快捷键会将当前光标所在行居中 移动 %该快捷键实质上是shift+5两个键的组合，可以让你的光标在成对的括号间跳转，例如大括号、圆括号、方括号等，该功能在写代码时经常使用。 移动 */#/n/N *：在文件中查找光标下的单词(向下)，如果要继续查找，可以按n向下查找，按N反向查找 #：在文件中查找光标下的单词(向上)，如果要继续查找，可以按n向上查找，按N反向查找 移动 [[、]]、{、}这套指令也特别容易记忆，因为大括号或花括号的方向即是你的光标所移动的方向 [[：将光标移动到上一个代码段（或函数）的行首 ]]：将光标移动到下一个代码段（或函数）的行首 {：将光标移动到上一个空行行首 }：将光标移动到下一个空行行首 以上是在普通模式中最常用的移动操作，熟练掌握以上操作，Vim便成了你手中的“六脉神剑”，可以任由你“指哪打哪”了。 u/ctrl+r u：撤销 ctrl+r ：重做 编辑 y/yy/p/P/+”y/+”p这几个命令表示基本的复制和粘贴 y：复制，比较常用的是先进入可视模式，然后按y，复制所选文本 yy：复制一整行 p：从光标右边开始粘贴，注意不能粘贴到Vim外的程序中 P：大P，从光标左边开始粘贴 +”y：复制到系统剪贴板，这样就可以粘贴到Vim外面去了 +”p：将Vim外复制的内容粘贴进来 +”y/p这种三个键的快捷键不是很方便，所以我们可以在vim中建立按键映射，将它的操作简化，例如在~/.vimrc（没有该文件的情况下要手动创建）中加入： 123456" 定义快捷键的前缀，即&lt;Leader&gt;let mapleader="'"" 在可视模式下，'+y则为复制到剪贴板vnoremap &lt;Leader&gt;y "+y " 普通模式下，'+p则为从剪贴板粘贴到Vimnmap &lt;Leader&gt;p "+p 编辑 a/i/A/I/r/cc/cw这几个快捷键可以帮助你编辑文本 a：从光标右边开始插入，进入插入模式 i：从光标左边开始插入，进入插入模式 A：从行尾插入，进入插入模式 I：从行首插入，进入插入模式 r：替换光标下的字符，不进入插入模式，例如rx，将光标下的字符替换为x cc：修改光标所在行，进入插入模式 cw：修改光标开始以右的单词，这个组合键在编码的时候也经常使用，Vim中的组合键由动作+ 范围组成，如c为修改动作，w为一个单词的范围，再如d2j表示：删除光标所在行及下一行，其中d为删除动作，2j为下两行 编辑 .点号键可以帮你重复上次编辑操作，例如你想手动将文件中所有的int转换为int64，只需要： 进入普通模式，将光标移到int下 敲击*查找int 敲击cw替换int，输入int64 按ESC继续进入普通模式 敲击n查找下一个int 敲击.重复执行替换，然后继续执行第5步骤 编辑 插入模式没什么可说的，在这种模式下和其他编辑器没有什么区别，下面说下可视模式 v/V/ctrl+vv、V或ctrl+v进入可视模式，在这种模式下你可以自由选择你需要操作的文本，然后进行批量操作 v：进入可视模式，按[n]hjkl调整范围，n代表分别对hjkl做的次数，例如v10l表示选择光标右边的10个字符 V：选择光标下的行，V10j表示选择光标及光标下的10行 ctrl+v：可以选择一个块状的区域，这个功能能够很好的帮你完成块注释或块反注释 下图展示了我将某一个代码块注释掉的动作 首先ctrl+v，然后敲击6j，垂直选择6行 输入:s,^,//,|noh将行首替换为注释符号//，noh是禁止高亮的意思 选择 命令在Vim中可以通过输入命令的方式进行交互，在普通模式下，输入:调出命令栏——Vim最底部的一栏，命令分为两种 Vim调用shell的命令，前面要加一个感叹号，例如输入:!pwd执行pwd Vim内置或用户通过插件实现的命令，例如下面的几个常用命令 :/ :?查找命令 :/id：从当前光标向下查找文件中的id字符串，为了方便，你可以直接敲击/id :?id：从当前光标向上查找文件中的id字符串，为了方便，你可以直接敲击?id :%s,Id,ID,g:s为替换命令，上文可视模式中已经展示了批量替换的威力，另外一种比较常用的是全文替换，例如:%s,Id,ID,g表示将全文中的Id替换为ID，g的意思是一行里面如果有多个匹配项，则都进行替换，和sed中的替换是一个概念 :q :w :x :e学到这里你已经掌握了Vim中的基本用法，现在可以退出休息一下了:) :q 退出 :w 保存 :x 保存并退出 :e 编辑文件，不存在则创建，例如:e ~/.vimrc会编辑~/.vimrc这个文件 :help即便看完了以上内容，你可以顺使用Vim了，但最好还是浏览一遍帮助文档，这样当你遇到某个问题时，可以通过help进行查找。 Window,BufferVim一次可以打开多个文件，同时打开的文件暂存在Buffer对象中，每个打开的文件对应一个buffer对象，你可以选择性的通过打开某个Buffer来显示对应的文件，而一旦该文件显示出来，用来显示该文件的窗口被称为Window，如果你的屏幕够大，你可以把Vim分成多个窗口，即实现了多个文件同时进行编辑的功能，非常方便你编写代码。这也是Vim和其他编辑器在理念上不一样的地方，其他编辑器使用Tab来打开多个文件，虽然Vim也有Tab功能，但Window+Buffer的方式更符合习惯 :split vsplit ctrl-w+h/j/k/l这几个是Vim中操作窗口的命令 :split 将光标所在的Window分为上下两个窗口 :vsplit 将光标所在的Window分为左右两个窗口 ctrl-w h/j/k/l 帮助你在不同窗口间进行切换，h/j/k/l分别代表了切换到左/下/上/右窗口 看完了以上内容，再看这幅浓缩图，就会觉得格外清晰 配置Vim是高度可定制的编辑器，你可以通过配置从而把它打造成一个非常强大的IDE，而所有的配置基本上都在~/.vimrc中完成，非常方便管理，网上讲配置的文章和文档非常多，相信你可以在网上找到你想要的内容。 插件插件本质上是配置的一种，而掌握了Vim插件的安装和使用后，你就可以将Vim运用到实际工作中了，基本的逻辑是，先明确自己的需求，然后在google中搜索对应的关键字便可以找到你所需要的插件，这里就介绍一个非常重要的插件 NERDTreeNERDTree插件配合窗口功能非常好用，NERDTree插件可以帮你列出系统中的目录和文件树，打开其中文件的同时，还可以帮你进行分屏，有了这样的插件，你应该会更得心应手。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React最少必要知识]]></title>
      <url>%2F2017%2F01%2F09%2Flearn_react%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 去年8月左右，看到了ThoughtWorks发布的2016年技术雷达，里面重点推荐了react.js技术，加上前端技术栈三足鼎立中，react也占据一席，其他两个分别是vue.js及angular.js，而react和其他两个的区别在于，它颠覆了整个技术栈，自成一派，抛弃了HTML和DOM，引入了JSX语法，让程序员可以更专注于逻辑代码。这一切让我对react.js充满了好奇，决定花时间学习一下，一探究竟。 本次学习我更采用了刚学到的元学习法，抛弃了曾经一贯的从基础开始的学习套路，毕竟后者周期较长，在只能用碎片时间学习的情况下，如果不能快速看到效果，学习目标很可能会夭折。在学习之前，我列了以下几点 写下为什么要学，学它是不是会让我非常激动 我终于学会前端开发了我可以了解前端开发的思路，对我以后的程序设计有帮助（vue和react都是号称可以解决复杂问题的技术，而jQuery已经心有余而力不足）我还想玩玩ReactNative 如果要学，计划是什么，第一个小目标要到什么程度 工作日下班后花1个小时，周末花半天学到可以看懂代码，自己可以写出简单的应用，为深入学习铺路 选材，遇到问题如何解决 在github上搜索React Demo，直接找最简单的Demo练习找最权威的教程方便检索，最后找到了官网和阮一峰的博客，ES6入门 定下了目标和计划后，就开始行动，今天为止，已经完成了目标，这个目标尽管很小，但足以让我搞懂React及Redux框架的重要知识点，以及能够帮助我继续深入学习。下面就分别来说一下整个学习过程，方便同样想学习的同学参考，毕竟网上有很多资料都是滥竽充数，不知不觉就会让你多走很多弯路。以下是我总结出来的最短学习路径： 0.搭建开发环境1.练习最简单的Redux Demo2.学会使用Create React App工具3.练习React-Redux框架 0. 搭建开发环境好的开发环境可以极大地提高你的开发和学习效率，曾经在公司用yum安装软件时掉进了一个大坑——没有使用yum国内镜像导致下载极慢，直到更换了下载源之后才追悔莫及，所以学习React之前的准备工作是 安装国内的npm镜像 配置编辑器，让其可以高亮、缩进、自动排版、补全等，这里就不具体说明，请大家自行google，因为每个人的编辑器可能不一样 1. 练习最简单的redux demo在练习demo之前，你需要先学习下React基本知识，这个教程写的非常好。 React并不会帮你组织代码，所以你需要选择一个框架，Redux是目前主流的React框架，它是Flux架构的一种实现。官网上有最简单的计数器demo，直接把这个demo下载下来，对着源码练习，你可以采用以下练习方法 第一遍：复制粘贴代码，注意每粘一段代码，就要对应看一下相应的输出，主要让自己脑海里有一个大致的框架：需要什么依赖，用了什么工具 第二遍：尝试理解代码的含义，不懂的话马上查找我上面说的”权威教程”，注意查找时只需要查找必要知识，千万不要不知不觉就把整个文档都看完才回来理解——时间伤不起啊。 第三遍：在理解的基础上尝试自己写代码，不会写了可以偷看一眼源码，这个过程会加深你对知识的理解，重复第三遍，直到你可以熟练写出为止。 此方法适合有一定编程基础的同学，因为在第二遍的时候就开始理解，学习曲线陡然提升，如果你是一个零基础小白，你可能需要首先了解一点html、js基础，同样可以在github上找几个最简单demo加以练习的方式，相信补这些知识也会很快。 这个demo是一个单页面的html文件，总共才60多行，mac下直接执行open index.html即可在浏览器查看效果，我在文档中加入了必要的注释，代码可以在这里下载，同时，你可以查看这篇教程对照学习。 2. 学会使用Create React App工具在学习Redux框架之前，你需要先学会使用Create React App这个工具，这个工具会自动帮你创建app环境，如果你之前没了解过它，可能会和我一样，在拿到React-Redux时直接懵逼，毕竟我们无法理解未知加未知的东西，所以在继续之前你需要先学会如何使用Create React App： 安装：npm install -g create-react-app 在指定目录创建一个app：create-react-app my-app 把我的demo2下载到本地，替换掉src目录中的文件和package.json文件 执行：cd my-app &amp;&amp; npm install &amp;&amp; npm start 这个工具其实很简单，以上步骤是告诉你，哪些是工具生成的，哪些地方是我们可以修改的，其中src目录一般存放我们的代码，而package.json是项目配置。 3. 练习React-Redux框架刚才你下载的demo2即是需要练习的demo，功能和demo1一样，只是组织方式有所不同，它更像一个”真实”的项目，练习方法和第1步里描述的一样，相信你很快就可以熟练 之后你可能会练习官网里的todos demo，但你很快会发现todos demo的代码复杂了很多： 一是因为它使用了我们还不怎么熟悉的React-Redux框架 二是它将组件分在了不同的文件中，转来转去很容易转晕 所以建议先读一下更简单的代码，demo3是个单文件的js代码，依然包括了React-Redux框架的必要的知识，通过执行npm install &amp;&amp; npm start来运行，练完这个demo之后你便会非常有信心去阅读todos demo的代码了。 以上是我实践出的React中的最少必要知识，接着你可以继续练习其他demos，或者做一些更完整的项目，如果你感兴趣，现在就开始吧，在编程领域，唯有不断练习才是最好的学习方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我们为什么要写作]]></title>
      <url>%2F2017%2F01%2F05%2Fwhy-write%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 几个月前看了几个超级大V的文章，他们都不约而同的在一段时间内鼓励读者们开始写作，他们说 写作可以锻炼你的思维能力写作可以解除自身的焦虑写作是一种创作写作是一种社交，可以认识更多志同道合的人 总之写作的好处很多，我被拥有这种能力所吸引，期待有一天，自己也能够像这些大V一样，坚持写作10年以上，也能够写出深刻的文章。可是几个月过去了，这一切都还停留在跃跃欲试阶段，迟迟没有开始，也许不知道从何开始，也许害怕自己像以前一样，没有准备就开始了，最后却不了了之。 今天早上起得很早，看了一篇关于写作的文章，文章里说： 写作就是记录自己的思考，如果不马上记录下来，你就会忘记你所思考的内容，即你也很难写出一篇完整的文章。 不管说得对不对，我认为至少对于新手来说，应该是有用的，我们大脑确实是时时刻刻都会产生不同的想法，但也确实很难回想起一个月前、一周前、甚至一天前的想法，如果不记录下来，用此时此刻的一些想法来形成文章是很有难度的，我们很难在一两个小时内把一段时间内所有想法回忆起来。 我害怕写文章，往往是因为这个原因——我脑袋里没有行云流水的供我输出的内容。所以我们需要有了想法就记录下来，日积月累会形成自己的写作素材，能够做到有话可说，有东西可写，我想，坚持写文章这件事就可以实现。 现在我们解决了可执行性（怎么坚持写文章）的问题，下面就来谈一下”为什么”的问题，看了很多作家、大V的文章，虽然当时我也特别渴望去做这件事，但毕竟那是别人给这件事赋予的意义，也许别人认为这样或那样的意义已经能够产生足够的动机，但真正能让自己认为这件事非常重要，非常有动力，还需要自己去思考，去说服自己，下面就来谈下对我来说，写作意味着什么 写作，是对自身的检查我是做互联网开发的，主要从事后端服务器相关工作，后端不像前端，有丰富的界面，相反，我们只能通过古老的字符命令和计算机交互，但服务器程序是每个互联网公司最重要的部分，它承载着每个公司所有的业务接入，例如，微信服务器集群，每时每刻都要接入上十亿的终端，作为中国人来说，应该最有体会，任何事情，只要数量一上来，就会变得相当复杂，但正是因为这样的国情，才造就了腾讯、阿里、12306这样能够并行处理海量数据的服务平台。 我对后端服务确实有一定的了解，我也知道，能够保障后端服务持续运作的有利手段就是记录日志，记录日志也是最简单的编程技巧，可能刚学编程的人都知道怎么写这个程序，差不多就是著名的Hello World!那样的语法，为什么它这么简单却这么重要，因为 我们会在程序出错的地方输出错误日志，方便排查问题 我们会将程序的接入行为以日志的形式输出，通过这些信息，我们可以提前判断在一段时间内接入数是否会有所增长，并做好调整来应对即将到来的变化，做到未雨绸缪 对于重要业务，每一个客户产生的流水，我们必须为他保留流水日志，一是方便他查看自己的操作记录，也可以帮助我们检查某些用户的数据是否异常 由此可见日志的重要性，假设没有日志，程序就像一个黑盒，我们无法判断程序是否正常运行，非常不利于我们开展工作，更有甚者，这种做法将直接影响公司的业绩，我相信任何程序员都不会为了偷懒而不去做这件事。 说了这么多，你可能会问了，这些和写作又有什么关系？ 计算机是用日志来帮助它正常运行的，没有日志，你就摸不着它的”生命”轨迹，同样道理，如果我们没有记录的习惯，我们也几乎记不得我们的生活足迹，表面上看不到我们会有什么损失，但在飞速发展的社会，自己的成长跟不上社会的发展，就是损失，《把时间当做朋友中》有一句这样的话： 时间过得飞快，我们却全然不知，这是一件多么可怕的事情 相反，如果我们记录生活中的想法，我们可以不断的总结，回顾，辩证的看待自己想法哪些好，哪些不好，有什么理论去支撑，从而不断改善，当你有了这些积累后，你便可以将它们写成文章，这时你会发现， 写文章并不是目的，检查自己，完善自己才是目的，写文章只是你的一个手段 所以，为了更好的自己，现在就开始写作吧。 写作给自己腾出了思考的时间我写这篇文章之前，正在跑步机上跑步，写这篇文章的想法也是在跑步机上产生的，我一直感到奇怪的事情是，为什么总是在跑步机上产生这样或那样的想法，而我大部分时间都没有跑步，为什么另外的大量时间里却很少有想法冒出来，最近我好像是想明白了，那是因为我们人害怕无聊，一旦有点时间，会迅速去找点事情做，这样就会感到不无聊，比如现在所有人一有时间就掏出自己的手机把玩，在时间被占得满满的情况下，我们很少有时间腾出来思考问题。反而在跑步、吃饭、通勤等不需要思考但必须要占用你时间的时候，你才会去不自觉的思考起来，怪不得村上村树有本书叫做《当我谈跑步时我谈些什么》。 有的同学会问了，我不是很努力吗，时间都排的很满，我也没玩游戏，这种状态很充实，有什么不好呢？可你有想过没有，如果你时间排的很满，没有安排时间思考，你是在重复使用过去习以为常的方法办事儿，没有刻意去优化自己的做事方法，而优化工作需要通过思考、总结及实践来完成，就像我们常说的一句老话”磨刀不误砍柴工”。 所以，我们需要腾出时间来思考，其实我们人类非常聪明，当我们长期忙于工作而疏于思考时，我们会创造一些行为去做这件事儿，例如旅行、健身、冥想等。我没有冥想的习惯，不知道它是否是因为能帮助人们思考，而衍生出来的产物，但我猜它有这样的作用。 你应该有这样的感觉，因为工作的原因，你忙得没日没夜，有时候甚至连吃饭睡觉都顾不上，更顾不上思考和总结，当事情终于结束，你可以名正言顺的请个年假，出去旅行，放松之后，再回到原来的岗位，你发现你的思维和做事方式都发生了变化，效率比以前更高了，我就有过这样的经历，我想是因为当你放下繁重的工作，有时间看到外面的风景、别人的生活方式时，你会时不时对照自己，思考自己这一段时间的经历，并潜意识的做了调整，所以我们才会经常说，每年出去旅行对自己帮助很大，但我们却’误打误撞’的得到了提升。 同样的道理，写作更是主动腾出时间来思考的行为，它需要你刻意花几个小时坐在桌前，打开电脑，整理你一段时间内的想法，这和平时记录想法的行为不一样，如果把平时记录想法看做收集、积累，那写作应该算是沉淀和升华，一篇文章的完成，需要你不断的打磨，当你回看过去的文章，或许还会发现其中的不足，因为你每次都会比上次写得好。 写作，是一种教育方式每个做了父母的人，都希望自己的小孩能够比自己优秀，但这本身就是一个矛盾的事情，毕竟你让小朋友学习的东西，你自己都很难做到，比如你认为英语很重要，希望你的小孩把英语学好，但同时你自己的英语水平却一般；而我们知道，父母的以身作则才是孩子学习最大的动力，既然他都无法从你身上体会到学英语的好处，你如何能让他这么小就理解长大后这种技能对生活的帮助呢？怎么能够保证学习过程中的一两次挫败不会让他失去信心，而产生对英语不感兴趣的错觉呢？ 毕竟兴趣这种东西，不是有兴趣才做得好，而是做好了，才会更有兴趣 所以我们无法直接解决这样的问题，那我们只能换一种间接的方式，既然以身作则才是关键，我们不一定非要和孩子做同样的事情，在同样的事情上给他树立榜样；深入思考就会明白，其实你是希望孩子能够成长，通过学习，能够让他体会成长的乐趣，最理想的情况下，他今后能够自发性的成长。所以，只要拿我们成长的过程这个例子来启发他，就足够让他明白其中的道理，即一个看得见，摸得着的成功的父母，比任何一本成功学书籍，或名人传记，都更有说服力。而写作天然的记录了你的成长过程，你的博客就是最好的证明，所以， 写作是一种非常好的教育方式 2016年底，我已经开始了，相信，你也可以开始写作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[年终总结，不要等年底才去做]]></title>
      <url>%2F2016%2F12%2F27%2Fstart-2017%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 眼看着2016年还剩1天，很多人在网上晒出了自己的年终总结，你也许会发现一个规律：晒总结的同学一般都比较厉害。我这里就摘抄下战隼老师2011年的年终总结(摘自《奇特的一生》)： 2011年计划完成12个习惯，实际完成8个 两个博客更新303篇文章，新增了40万以上的读者。 参加17个项目，结项15个，投标11次。 从2010年12月18日建立每天读一本书的习惯，进行了379天，看了419本，写了378篇简评，在学习博客上分享了46本书的笔记，笔记博客上分享了16本书的思维导图。 …… 书中一共写了11项，而我这里只列了4项，想必很多人已经被惊呆了，心想怎么会有这么高效，一年怎么能做这么多事情。所以这个时期，可以把上网的同学分为两类，一类是晒总结的同学，另一类则是羡慕第一类同学的同学。而后者一般比前者的数量多出好几个数量级。同时，我相信很多同学会默默下定决心：在新的一年里一定也要完成一些事情，也在年底发一篇年度总结，让其他人羡慕自己。因为曾经，我也有同样的想法。 往年我都是这样做的，在新年开始时，写上一个列表，例如： 每个月读1本书 每天跑5公里 争取公司年终优秀项目奖 学会摄影 …… 这些都是我想去做的，或者我比较感兴趣的，抑或是我看了某篇文章，想向文章中描述的一样，做点改变，而结果往往与当初计划的不一样，到了年底，发现自己大部分的计划没有完成，或者根本就没有开始。与此同时，也没有感觉到对自己有任何愧疚，相反还给自己找了一个万能的理由：计划赶不上变化。 直到最近，读了一些书，听了一些分享之后，突然意识到之前的想法是大错特错，悔恨当初浪费时间的行为。而让我恍然大悟的却是极其简单的道理，自己竟然全然不知，很多时候就是这样，观念的不同往往会驱动不同的行为，成功的人和平庸的人之间也仅仅存在一念一世界的差距，下面就说一下我思维中的两个误区。 我列的计划，也许并不是我认为重要的 有时候，我只看到了结果，而没有专注过程 做你认为最重要的事情这其实是我今天最想表达的一点，还是拿我上面的列表举个例子，可以看出我当初写愿望的时候，初衷并不是完全主动的，是因为看了别人的总结后，心想第二年自己也要写一个总结，虽然自己写出了列表，但仍然包含一些被动成分。所以如果主动，即便不看别人的总结，你都会自然而然的列出明年的计划，充分说明了你对这些想做事情的重视程度，也会在后续的时间内付诸行动。 之所以之前会失败，除了自己不够主动，其实最关键的是我并不认为这些事是最重要的，我把这件事列出来，也许是因为自己感兴趣而已，而感兴趣并不代表这件事重要，就拿摄影来说，我确实非常喜欢摄影，但也非常清楚作为一个程序员，摄影最多是消遣而已，如果不花足够多的精力在上面，你是无法将兴趣转化为价值的，除非你本职已经做得很好了，把时间安排的很合理了，利用摄影来陶冶情操，培养设计师思维，倒也挺不错的。再仔细分析之前列出的计划项，有的只是想满足自己的虚荣心，制定了一些不实际的计划，例如每个月读1本书，一到年底便可以晒出自己读了十几本，甚至几十本书是一种怎样的体验，但真正执行的时候发现非常困难，一是因为我工作本身就很忙，二是我对我选择的领域只是表面上的兴趣使然，并不是心里真正想学习这方面的知识，两方面原因一结合，就造成了工作时间挤占了其他的时间，目标最终没有完成。 要记住：一件事如果重要，你一定会想尽办法去做它，谁都拦不住你，这句话非常关键，一定要牢记并不断审视自己是否运用自然，虽然我很早就知道这句话，但最近才发现，我竟然从来没有思考过这样的问题，所以就造就了做很多事情仅仅停留在想想而已的阶段。每个人在生活中都有非常重要的事情，例如吃饭睡觉，也许你会说这是习惯成自然或是人的本能之类的。举个其他的例子，我们都会有追美剧的经历，当我们对某个剧情非常着迷时，我们会想尽一切办法，没有时间也要挤出时间来看这部剧后续的发展，这不是因为我们喜欢看电视，而是因为我们认为它很重要，它能够满足我们的好奇心，写到这里，我突然得出了另一个结论，即： 好奇心是你的原动力 如果一件事情能够满足你的好奇心，那它在你心里就是重要的，你就会为了满足你的好奇心，而去做这件事情，想想吧，上面说的追剧就是满足你获得剧情的好奇心，玩游戏上瘾是满足角色升级后的好奇心，专注个人成长是为了满足看到成长后的自己的好奇心。所以，在做计划之前，要反复的思考，这件事是否是你认为最重要的，你是否渴望想知道做这件事时产生的变化，不做它行不行，如果思考后的结果是不行，那请把它写在笔记本上。 专注过程，而不是结果写一个年底总结这件事，很容易让人走进一个误区，即 年底总结是年底才去做的事 而这样想的同学几乎完全写不出任何有价值的东西出来，纠其原因是因为我们人的大脑无法完整的回忆一年以来做的所有事情，所以依靠回忆来完成这件事情必然失败。而那些完成年终总结的人是怎么办到的呢，他们一般都有一个共同的特征：他们不会把年终总结作为最终目标，而把记录整年哪个时间点做了哪些事情作为一个目标，他们把这个目标转化成一个可执行的行为，换句话说，他们更专注于完成这件事的过程。 所以，如果你想做一份2017年的年终总结，就需要从明天开始，每天记录，定期总结，你会发现每个目标都在不断的前进，进而最终达成，希望在新的一年，你和我都能收获自己的成长。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用ElasticSearch踩过的坑]]></title>
      <url>%2F2016%2F12%2F17%2Fes-hole%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 使用ElasticSearch将近3个月了，在使用过程中，陆陆续续踩了不少坑，每次觉得无法逾越时，心里都想放弃，一是因为这东西要完全掌握不是那么容易，需要花很多时间；二是如果继续使用曾经用过的zabbix，说不定可以很快满足眼前的需求，从而可以抽身做其他事情。但坚持下来，就一定能从坑里爬起来，从而对这个系统更加了解，并利用这头”猛兽”帮助我做更多事情。原因很简单，ElasticSearch除了是一个分布式数据库，还是一个扩展性和可用性都很强的近实时搜索引擎。 目前为止，踩过以下几个坑： 集群搭建不成功 未使用内网IP，导致恢复缓慢 未使用队列及logstash，导致数据丢失 Master和DataNode未分离，导致集群不稳定 Logstash吞吐量问题 Logstash如何创建Mapping head插件安装错误 犯了这么多错误基本上都是使用不当、以偏概全的原因，以为看了一点文档，就凭直觉可以猜测到系统的所有内容，造成了后续问题的不断涌现，下面就逐一说一下淌坑过程 集群搭建不成功一开始是在单机上玩ElasticSearch的，上生产环境肯定要使用它的集群功能，但文档说只需要在elasticsearch.yml中设置cluster.name和node.name即可，ElasticSearch节点启动时会自动发现集群并加入到集群，但全部设置完毕后，竟无法使各个节点组成集群，最后发现这种方法只在一台机器上有效，而要组成集群，需要在每台节点做以下配置： 1discovery.zen.ping.unicast.hosts: [&quot;Node1_IP:9300&quot;, &quot;Node2_IP:9300&quot;, &quot;Node3_IP:9300&quot;] ElasticSearch一般会开两个端口，一个是集群维护端口，如上面的9300; 一个是对外提供的端口，默认是9200。 未使用内网IP，导致恢复缓慢在部署集群时，我挑选了几台配置相近的同网段机器，但当时其中一台机器操作系统没有加载内网网卡，为了偷一下懒，便直接使用了外网IP，集群是跑起来了，运行了一段时间也没有什么问题，但随着流量越来也大，终于有一天Master突然down掉了，我当时心想，ElasticSearch集群本身具有故障转移功能，马上会分配一个Master节点，然后我只需要把原先的Master节点重启即可，然而重启了之后，通过head页面查看恢复情况，发现集群长时间处于黄色状态（有replica shard丢失），而丢失的shard一直处于未分配状态，并没有如我预期的：启动后，该节点可以重用在磁盘上的shard数据，上报给Master，不需要数据拷贝，立马恢复为绿色状态。过了几分钟后，我发现恢复的shard数正以缓慢的速度增加，便推导出这样的错误结论：ElasticSearch在某一台机器挂掉后，只会从primary shard复制数据，即便节点迅速恢复，也不会复用该节点上的数据，如果是这种实现方式，我认为这种恢复速度是无法接受的，顿时产生了无法继续使用下去的念头，当时的心情是无比失落的。 而ElasticSearch的使用是相当广泛的，我们熟知的世界最大同性交友网站也是使用它来实现搜索功能的，所以可以断定是我的使用方法有问题，要么是我选的版本不稳定，要么是其他的原因，而稳定版一般出问题的几率不大，因此在换版本之前，需要找其他方面的原因，很久之前看过一篇google的slide，上面有一页介绍了不同介质数据的传输速度：外网的传输速度在10ms级别，而内网却在20微秒级，这种速度的差异便会造成以下几个方面的影响 集群无法提供正常服务：因为每个请求，ElasticSearch节点都会经过转发和收集两个过程，如果使用外网网卡，便会造成延迟大，访问量上不去，而流量到达一定程度后，集群很快便无法提供正常服务 由于ES集群已经无法正常服务，所以down机、恢复困难一系列综合症的情况便会陆续发生 后续我将集群切到了内网中，再测试重启某一个节点，便不会再出现恢复一个节点需要半天的情况了。 未使用队列或logstash，导致数据丢失最初用到的架构非常简单: 使用ES（ElasticSearch缩写）集群作为存储，beats和rsyslog作为shipper向ES集群发送数据，使用这种架构的主要原因是配置简单，ES本身是一个高可用集群，直接把数据发过去就好。而自己心里还产生了为什么会有ELK架构，感觉Logstash是多余的想法，在发生了几次down机之后，才发现之前的想法很傻很天真，之前的架构也有明显的问题 在某一个节点down掉后，如果不马上恢复，在不了解beats负载均衡机制的前提之下，很难判断数据还会不会发送给down掉的节点，而新增一个节点，需要修改所有beat的配置，即这里至少要使用一个负载均衡器给所有ES节点做负载均衡 ES是一个高可用集群，但目前还没有足够的使用经验，所以可能今后还会出现集群故障的问题，而出故障，很可能造成数据的丢失，为了避免这种情况发生，需要在beats和ES集群之间构建一套可持久化的队列，最简单的队列是redis，而logstash放在redis两边分别作为生产者和消费者。想到的方案便是beats-&gt;logstash-&gt;redis-&gt;logstash-&gt;ES，这样便解决了丢数据的问题，当然最新版的logstash可以将数据持久化到磁盘上，也许可以对此模型进行简化 Logstash和Redis的使用都非常简单，这里就不一一介绍，值得注意的是，如果要使用redis做持久化，需要使用Redis的List的方式，而不是Sub-Pub的方式，以下是具体的架构图，箭头的方向是数据流动的方向。 Master和DataNode未分离，导致集群不稳定在ES集群中，节点分为Master、DataNode、Client等几种角色，任何一个节点都可以同时具备以上所有角色，其中比较重要的角色为Master和DataNode: Master主要管理集群信息、primary分片和replica分片信息、维护index信息。 DataNode用来存储数据，维护倒排索引，提供数据检索等。 可以看到元信息都在Master上面，如果Master挂掉了，该Master含有的所有Index都无法访问，文档中说，为了保证Master稳定，需要将Master和Node分离。而构建master集群可能会产生一种叫做脑裂的问题，为了防止脑裂，需要设置最小master的节点数为eligible_master_number/2 + 1 脑裂的概念：如果你有2个Master候选节点，并设置最小Master节点数为1，则当网络抖动或偶然断开时，2个Master都会认为另一个Master挂掉了，他们都被选举为主Master，则此时集群中存在两个主Master，即物理上1个集群变成了逻辑上的2个集群，而当其中一个Master再次挂掉时，即便它恢复后回到了原有的集群，在它作为主Master期间写入的数据都会丢失，因为它上面维护了Index信息。 根据以上理论，我对集群做了如下更改，额外选取3个独立的机器作为Master节点，修改elasticsearch.yml配置 123node.master = truenode.data = falsediscovery.zen.minimum_master_nodes = 2 修改其他节点配置，将其设置为DataNode，最后挨个重启 12node.master = falsenode.data = true Logstash吞吐量问题在使用了新的架构后，我发现了当流量上来后，Redis的队列会持续增长，消费速度跟不上生产速度，造成的问题是数据在Redis中堆积，图表展示有大量的延迟。解决这个问题有以下几个思路 可能是ES插入速度太慢，需要调整参数提升插入性能 可能是Logstash吞吐量低，需要增加每次向Redis拿数据的缓存、增加向ES输出的缓存、增加线程数、增加每次批量操作的content length等 对于ES调优中，我调整了线程数，增加线程队列，增大shard数，但都没有解决问题。 而Logstash调优，我首先调整了LS_HEAP_SIZE参数，让Logstash可以同时处理大量的数据，然后主要专注在调整Logstash的Input和Output插件参数上，插件中可以设置线程数、batch_count数值等，而当我将Redis插件参数改为batch_count=&gt;10000后，发现队列不再一直增长了，它会涨到一定程度后，瞬间减少到2-3位数，即队列的长度在一定范围内浮动，当时欣喜若狂，以为自己解决了，但跑了大概5个小时候，发现队列又开始不断增长了，问题并没有得到解决。而产生解决了的假象应该是我增加了Logstash内存的原因，数据只是先把Logstash内存填满，再开始填队列，而填满Logstash内存花了几个小时，关键的Logstash到ES的吞吐量还是没有上去，在access日志中，无论如何也无法让bulk API的content length增加，如下图中的长度一直维持在2K左右。 最后，我采用了替换Logstash版本的策略，更新了时下最新的5.1.1版本，由于新版的配置和旧版配置不一样，所以认真研究了一下配置，在这个过程中，我发现了一个-b参数可以修改批量插入的大小，也许就是我需要的。果然，将这个参数由默认的125改为了1000，顺利的解决了这个难题，同时也证明了并不是版本问题，还是使用问题，而这个参数也正是修改content length的方法，顺便说一下，如果你使用nginx作为负载均衡器，你需要同时增加client_max_body_size参数，避免产生content length过大而返回413错误码。 Logstash如何创建Mapping当使用Logstash进行转发时，有可能你的数据都在一个Index中，当然你也可以设置不同的Index，这篇文章中就有根据type来划分Index的方法，不管划不划分Index，都会默认生成一个或多个mapping结构，mapping结和不同的type即对应MySQL中的数据库和表结构信息，当然我这里不是为了说明它们的区别，而是我们无法自定义字段的类型。 这会产生各种各样的问题，比如它会默认产生analyzed类型的string字段，会自动将带有连接符的字符串分为两个字符串输出，即”idc-1”这样的字符串会输出为”idc”和”1”，这并不是我想要的，让我相当困扰，而Mapping在生成后是无法修改字段的，除非你换一个新的字段。 解决这个问题的方法并不在mapping上，而我却花了很多时间在这个上面，最终答案却是使用template，在template中可以定义你需要的mapping，这样便解决以上问题。到此，我还是不能完全理解里面的机制，以后抽空了解后再补上。 head插件安装失败上文有介绍head插件，它是一个可以显示集群状态及操作ES集群的UI，可以取代官方的X-Pack，后者只有30天的试用期，因为创业公司，能用免费的尽量采用免费的。在集群中，有几个节点安装该插件会失败，提示：Unable to veryfy checksum for download plugin ...，google上查了一圈仍然没有找到解决办法，最后试着手动将该插件下载然后解压到/usr/share/elasticsearch/plugins/目录下，并将目录改为head即可解决该问题。 以上问题是我这段时间来碰到的坑，每个都花了不少时间去解决，自己也比较幸运，花在上面的时间没有白费。因为个人觉得这个技术栈实在是比较好，而资料主要以英文的为主，把自己的经历写下来，希望今后不再犯同样的错误，也希望可以帮助其他使用该技术的同学。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[元学习记录（一）]]></title>
      <url>%2F2016%2F12%2F08%2Fstudy-study-study%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 本文是对周一元学习课的一个记录，这门课是为了帮助老婆学习一些学习方法，自己顺便也了解一下，记录的目的是为了帮助自己消化，把别人的知识变成自己的知识。 什么是元学习：元学习是学习学习的方法，再继续学习。目的是使用正确的学习方法让自己在今后的学习过程中更加高效，我觉得花点时间去了解这些东西很有帮助，磨刀不误砍柴工。 拿编程作为引子，如何高效学习编程， 首先要理解编程的概念： 编程就是观察一件事的输入，输出，并用计算机让这件事能够重复被做。当碰到A的时候，就执行B，当碰到C的时候，就执行D。 从以上概念可以看出编程的特点是可以重复的完成一些工作，普通人学会编程可以带来什么变化？编程可以让你从重复劳动中解脱出来，即节省了你的时间，让你能够有更多注意力关注到你需要关注的事情上，而这才是学会编程的最重要的价值。第二个重要的价值还是可以从概念中抠出来，就是观察一件事的输入、输出，把它写成程序的这个过程，这个过程用到了把一件复杂事情拆解成很小的单元的思维方式，学会这种思维方式，可以帮助你学习大多数未知的知识。 编程学习的三个步骤： 学习不是登山，学习是拼图，拼图的方法是先拼边框，再把中间一块块拼起来。意思是先了解你要学的记录的边界，然后需要用的时候就去学哪一块知识，比如你在了解了边界之后，就开始做项目，遇到问题就去学习相应的知识，现学现用。 获得反馈。你每成长一点，可以讲给你的朋友听，获得正向反馈，并激励自己不断进步 大量的重复训练，让低频变高频。 传统思维是先学基础，先学算法，学好了再去编程，但我们刚生下来时并不是这样学习的，如果我们要学会力学才开始走路，可能3岁还在地上爬。所以，我们不要害怕学一门新的技能，直接去用就好了，用多了自然就会了。 画画是一件很难的事情，对于初学者来说，要想画出自己的自画像最有效的方法是倒着画。究其原因是因为正着画的话，你会一边画一边纠结自己画的不像，会死劲思考应该如何画，但我们人脑是很难用未知来解释未知的，以上思维过程其实是一种左脑思维，左脑控制的是逻辑。在学习一项新技能时，我们要开启右脑思维，右脑主要控制感官，轮廓，图案等，而倒着画自己的画像正是把你的左脑思维关闭，让你专注于绘制自己的轮廓，所以学习一项技能也一样，先不要想它为什么是这样，先感受它，把它用起来吧。 拖延的本质是你对它产生恐惧，害怕自己会失败，所以尽量回避这件事，从而造成了拖延，解决拖延的一个很好的办法是骗自己不一定要成功，而是用一种玩玩而已的心态去做这件事，心态放低，开始做了，自然就不拖延了。 了解ORID方法，学会使用ORID方法做记录。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端开发应该怎么学（含CSS布局练习）]]></title>
      <url>%2F2016%2F12%2F03%2Fcss-layout%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 1. 价值我是一个对后端有一定经验的程序员，一直从事相关的工作，不过我对前端也挺感兴趣的，总想学点前端的技术，做点东西来玩玩，比如做个写周报的页面，这样就不需要花时间去整理周报内容；再比如利用这些知识定制开源的监控页面，让它更贴近我们的需求，或者利用前端做一些运维自动化工作。当然目前想到的这些对自身的改变都不大，无非是多学习一种程序语言，但我心里一直笃信，如果能够同时掌握前端技术，对我整个人的价值提升是无法想象的。 前后端原本是不分家的，一个公司刚开始的时候，不管前端还是后端代码，应该是一个人，或少数几个人一起做出来的，只是随着公司发展过程中管理的需要和分工协作的原因，前后端分离这件事才越来越明显，导致现在许多人一进入公司，就只会做前端，或另一部分只会做后端，而且保持十几年不变，在我看来，作为一个后端程序员，如果不了解前端，属于技能上的缺失，不仅无法独立完成一个完整的产品，而且在思维上不会站在前端程序员的位置上思考，即将来如果成为一个系统设计师，设计出来的软件也很有可能存在缺陷，反之亦然。这也是为什么整个行业越来越鼓吹全栈工程师，这个概念并不是虚幻不实际的，而是企业对人才的一种实实在在的需求，即人们常说的复合人才的一种，全栈工程师对于一个企业来说价值巨大。 2. 失败经历我学习前端开发断断续续也有几年时间，总是想着自己有不错的基础，应该不费吹灰之力就可以学会，有一两次还做了些计划，例如每天跟着w3school学半个小时，相信自己十几天之内就可以掌握，但一方面因为自己工作也比较忙，另一方面因为计划不太实际，没有收到相应的成效，最终都以从入门到放弃告终。最近花了些时间学习学习的方法，再次总结之前的失败原因，发现以前失败主要是因为自己的重视程度不高，加上前端技术栈确实庞大，如果随随便便就可以学到的技能，那其实本身它的含金量就不高；学习任何一个新技能都应该注重它的学习过程，首先要分析这个技能的主要框架，然后针对框架的每一个知识点，做大量的实践及练习，这样你才能够’快速’学会一门新技能。 曾经有过这样的经验，公司要开发一个云存储系统，为了完成这个需求，我引进了一个开源的云存储项目，并将其进行修改，让它符合公司的需求，这个开源的项目自带一些运维可视化的工具，是用AngularJs和BootStrap做成的，当时我也花了些时间看懂了这些代码，以为自己以后就会使用这些技术来做可视化了；但真正要开发新的项目时，我并不能很快利用AngularJs和BootStrap为我所用，即便花很多时间做得和以前一模一样，我也很难在上面添砖加瓦，或做得比以前更好。根本原因在于我没有了解前端开发的全貌，不知道某些技术的主要用途是怎样的，只看代码而不实践也是无法让技术成为自身技能的。 3. 领悟直到最近，我在github上发现了free code camp社区，全世界最大的学习前端开发的社区，我同时也鼓励零基础的老婆在上面学习，希望有一天她可以通过学习一门编程语言体会到成长的乐趣。在fcc中国社区，作为自愿者，给他们翻译了几篇前端学习的入门文章： Things you probably didn’t know you could do with Chrome’s Developer Console I finally made sense of front end build tools. You can, too. From Zero to Front-end Hero (Part 1) From Zero to Front-end Hero (Part 2) 在翻译的过程中，其实对我帮助比较大的是英语能力的提升，让我专门腾出时间来利用英语进行翻译工作。其中最后两个翻译的文章，是点击量最多的，反映了翻译水平比以前有了提升，同时这两篇本身质量也非常高。其原因在于文章给初学者规划出了一个版图，读者拿着这个版图，对每个版图分别进行实践，就可以把其中的知识据为己有，注意，如果你只看文章而不实践，是没有用的，知识不会因为你看了文章而自动钻到你的脑袋里。 所以，说到这里，最佳的学习前端的方式是实践，而最佳的实践其实文章中已经说了：依葫芦画瓢，即把例子原封不动的克隆一遍。当然尽量不要ctrlC + ctrlV。 From Zero to Front-end Hero系列真的不错，我现在已经按照文中的路线在练习，从布局开始，已经学会了基本的布局方式，以及知道了平时看到的一些交互式页面，其实是通过CSS的技术做出来的，例如Media Query技术可以自动适应pc浏览器和移动端浏览器。关于布局的练习，我把它保留在了我自己的CodePen中，里面都有源码，还等什么，赶紧动手把，相信你也可以做到，原布局练习教程在这里。 本文没有提到科学上网、英语能力等，这些不是必要的，但它们确实会带来很大的帮助。 希望本文可以给你带来帮助，如果你喜欢这篇文章，可以将其分享到社交网络中，如果你有任何问题，可以在文章后留言，或者通过社交网站找到我。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用ElasticSearch监控MySQL]]></title>
      <url>%2F2016%2F11%2F24%2Fmysql-monitor%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 介绍本文是一个使用ELK来监控mysql的介绍，基本监控了一些关键指标，当然根据业务的不同，可能有不同的指标需求，但使用该方法监控，原理不会变化，非常适合入门。 ELK是一个非常强大的软件组合，在github上有开源，star数大的惊人，感兴趣的朋友可以了解下，这套工具学习曲线比较陡峭，推荐使用本文提到的mysqlbeat这类简单的工具作为采集工具开始，一开始先不使用官方提供的beat，一方面是因为默认的配置什么数据都上报，浪费存储空间，另一方面复杂的嵌套表结构（document）更增加了学习难度，更具体的原因后面还会提及。而本文涉及到的表结构（document）只有一层，说不定你输入一个key:value，例如INNODB_PAGE_SIZE:16384，就把pagesize为16KB的记录全部列出来了。但这并不意味着你不会掉到坑里去，学好这套工具还是需要大量的学习和摸索，其实ELK的难点在于ES，建议可以读一下它的原版教程ElasticSearch权威指南。 监控工具mysqlbeatmysqlbeat是一个高度可定制的mysql监控agent，通过查询information_schema.global_status中部分字段，并上报到ElasticSearch进行存储，并通过Kibana进行可视化展示。代码量少，建议阅读，github地址。 数据上报安装后主要对/etc/mysqlbeat/mysqlbeat.yml文件进行配置（不同平台上路径可能有差异），有以下设置项： mysqlbeat：配置mysql账号，上报间隔，查询语句等 output：ElasticSearch集群的地址（也可以输出到logstash），可以同时设多个，例如：hosts: [“192.168.1.1:9200”, “192.168.1.2:9200”] template：ElasticSearch mapping模板路径，默认为/etc/mysqlbeat/mysqlbeat.template.json，定义了文档字段（初学者可以理解为关系数据库的表结构），如果你偶尔要添加或修改字段，请设置overwrite: true字段，同时需要在Kibana界面reload一下该模板 配置中最重要的是queries字段，定义了一系列SQL语句，mysqlbeat通过执行这些语句，会生成一张表，这张表就是你要监控的数据，它只有两个字段VARIABLE_NAME和VARIABLE_VALUE，分别代表你要监控的监测名和监测值，其中value有两种类型 第一种是差值类型，因为global status中的一些数据是不断累加的，所以要得到1s内的数据，需要用当前时间取到的值减去前一个间隔取到的值，然后除以间隔的秒数，当然这些都不需要你来完成，你只需要在监测名后面加一个后缀__DELTA即可：CONCAT(VARIABLE_NAME, &#39;__DELTA&#39;) 第二种是像内存值这样的不需要进行差值操作的类型。 总之使用很简单，看一下配置，然后马上就try吧 数据展示使用这个工具导出的数据很容易配置可视化，我目前使用的是标配Kibana作为UI，下图是mysqlbeat可视化配置和官方beat可视化配置的一个对比 左图X轴是时间轴，Y轴是QPS的平均值，非常清晰明了。再看右图，我只展示了X轴，X轴是一个外部是时间轴，内部还嵌套了一个过滤器，这个效果却是对垂直空间做了划分，对于初学者来说非常不直观，可以想象当初我为了实现这个展示是花了很多时间去摸索的，即便如此，也不能否认ElasticSearch本身非常强大的事实。 监控指标QPS和TPS qps是每秒的查询数，即information_schema.global_status中的QUESTIONS字段 tps是每秒的事务数，是information_schema.global_status中COM_ROLLBACK和COM_COMMIT之和 连接 使用数据库的时候会出现”mysql connection error”的错误，一般有两个原因 连接数到达配置的最大值 内存或线程不足（每个连接对应一个线程） 所以需要设置如下几个监控 THREADS_CONNECTED：当前连接数，对照MAX_CONNECTIONS，如超过总连接的80%，或陡然突增的情况，需要设置报警 ABORTED_CONNECTS：表示存在服务器拒绝client连接的情况，此时下面两个指标中的一种或两种会增长 CONNECTION_ERRORS_MAX_CONNECTIONS：连接失败是因为当前连接超过最大连接数 CONNECTION_ERRORS_INTERNAL：主要用于排查连接失败是因为内存或线程不足造成的参数 缓存 缓存在互联网时代的重要性不可估量，主流的两个数据库引擎InnoDB和MyISAM的缓存作用有所区别，前者的缓存包括了索引和实际数据，而MyISAM仅缓存了索引，它把数据缓存交给了操作系统，在这里我们的监控原理一样，只是字段有差别: 监控缓存使用率 监控缓存命中情况 缓存使用情况需要两个参数，缓存使用大小和缓存总大小 MyISAM：KEY_BLOCKED_USED / (KEY_BLOCKED_UNUSED + KEY_BLOCKED_USED) InnoDB：INNODB_BUFFER_POOL_PAGES_DATA / (INNODB_BUFFER_POOL_PAGES_FREE + INNODB_BUFFER_POOL_PAGES_DATA) 同样，缓存命中情况也只需要缓存访问量和磁盘访问量两个参数，这一组字段不好记，记住读缓存次数的变量名比读磁盘次数的变量名多个requests后缀就好了。 MyISAM：读命中 KEY_READ_REQUESTS / (KEY_READS + KEY_READ_REQUESTS)；写命中 KEY_WRITE_REQUESTS / (KEY_WRITE_REQUESTS + KEY_WRITES) InnoDB：缓存命中 INNODB_BUFFER_POOL_READ_REQUESTS / (INNODB_BUFFER_POOL_READ_REQUESTS + INNODB_BUFFER_POOL_READS) 需要注意的是，缓存的读/写命中率应该以最近一段时间（比如10s）为基准（而作者取的是累积值），这样数据更真实，而基数太大会把数据压得更平滑，不利于监测突发情况。 TODO 主从同步延迟，其实mysqlbeat已经实现了，只是老是出现类型冲突，所以就无法可视化，需要查代码定位 mysql错误，这种以表格的形式展示更好，对错误语句、原因根据错误次数倒序展示 最慢的mysql语句，同样是以表格形式展示 报警，使用ElastAlert的spike rule监控陡然增减的情况、frequency rule设置阈值，出现这些情况进行报警 latency，这种优先级比较低，一般上层接口的监控latency即可，因为一般情况下，mysql都是瓶颈。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端开发，从草根到英雄（第二部分）]]></title>
      <url>%2F2016%2F11%2F12%2Fzero-hero-2%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 这篇文章是”前端开发，从草根到英雄系列”的第二部分，在第一部分，你学到了如何使用HTML和CSS创建布局的最佳实践。在第二部分，我们会把JavaScript作为独立的语言来学习，我们将学习如何添加交互式的接口，JavaScript设计以及设计模式，最后我们会学习如何创建web应用。 和HTML、CSS一致，网上有大量的JavaScript指南，对于新手来说，很难分辨这些指南分别的用途，也不知道以怎样的顺序去学习这些指南。这篇文章的目的是给你提供一个线路图，作为你成为一个前端工程师的导航。 如果你还没有阅读第一篇，在读这篇之前，可以点击下面的链接阅读 JavaScript基础 JavaScript是一个跨平台的程序语言，它几乎可以做所有事情。在你了解了开发者如何使用JavaScript的基础之后，我们再详细的探讨这门语言。 语言在学习JavaScript是如何应用于web之前，首先了解这门语言本身。我们来读一下Mozilla开发者网络的Language basics crash course，这个指南会描述基本的语言结构，包括变量，条件和函数。在此之后，再读一读MDN的JavaScript指南的以下几个部分: 语法和类型 控制流和错误处理 循环和遍历 函数 不要过于担心记不住特定的语法，你随时可以回过头来查阅。相反，你要专注于像变量实例化、循环和函数等概念上。如果一时消化不了是正常的，可以适当的略过，学完后面内容再时不时回顾一下前面的内容。因为当你练习这些概念时，你才会对这些更加深刻。 为了打破单调的纯文字内容的学习，可以看一下Codecademy提供的JavaScript课程，它很容易上手，并且非常有趣。同样的，如果你有时间，对于每一个我上面列出的概念，读一下Eloquent JavaScript相应的章节，相信可以加深你的理解。Eloquent JavaScript是一个非常棒的在线书籍，几乎所有的有追求的JavaScript前端工程师都会阅读它。 交互 JavaScript作为一门语言，你已经对它有所了解，下一步要了解它如何应用于web，要了解JavaScript是如何与网站交互，你需要知道文档对象模型（Document Object Model） DOM是HTML文档中具体的结构，它是对应于HTML节点的、由JavaScript对象构成的树型结构，更进一步，你可以读一下CSSTricks发表的什么是DOM这篇文章。它对DOM提供了简单直接的描述 JavaScript可以修改DOM元素，这里有一个选择HTML元素并修改它的内容的例子： 12var container = document.getElementById(“container”); container.innerHTML = &apos;New Content!&apos;; 不要担心，这仅仅是一个简单的例子，你可以通过JavaScript “DOM操作”做更多的事情。想学习更多关于JavaScript如何与DOM交互的内容，你要通过以下MDN部分的指导，The Document Object Model 事件 使用DOM开发web和XML的例子 如何创建一个DOM树 DOM简介 使用选择器定位DOM 再次强调，把注意力集中到概念而不是语法上。试着回答以下问题： 什么是DOM？ 如何查询元素？ 如何添加事件监听者？ 如何合适的改变DOM节点属性？ 要获得一个通用的JavaScript DOM操作列表，可以看一下PlainJS提供的JavaScript函数和帮助，这个网站提诸如如何设置HTML元素样式和连接键盘事件监听者等例子，如果你觉得还不够想更深入，你都可以阅读Eloquent JavaScript中的DOM部分。 检查要调试JavaScript，我们使用内嵌在浏览器中的开发工具，几乎所有的浏览器中都会有检查面板，通过它你可以查看页面的源码，你可以查看JavaScript的执行，在终端上打印调试状态，还可以查看网络请求和回复。 这里是Chrome开发工具指南，如果你使用的是Firefox，你可以查看这个指南 基本练习目前为止，我们还有很多JavaScript知识要学习，上一章我们已然学了不少新知识，现在我们休息一下，然后做几个小实验，他们会帮助巩固你刚学的一些概念。 实验1进入实验1，我们打开AirBnb，同时打开浏览器页面检查，点击终端标签，在终端里你可以执行JavaScript语句。我们将要做的事是从操作一些页面中的元素而获得一些乐趣。试试看，你是否可以进行下面将要描述的所有DOM的操作。 我选择AirBnb的页面是因为它们的CSS类名非常直接，不会被一些编译器处理的模糊不清，所以你可以选择性的在任何页面做这些操作： 选择一个具有唯一类名的header标签，改变其中的文字 选择任何页面上的元素，然后删除它 选择任何一个元素，改变它的某一个CSS属性 选择一个指定的段落标签，将它下移250个像素 选择任何组件，例如一个面板，调整它的可视性 定义一个函数名doSomething: 可以弹出”Hello world”警告，然后想办法执行它 选择一个特定的段落标签，让它监听一个click事件，一旦该事件触发，则运行doSomething 如果你卡住了，可以在JavaScript Functions and Helpers中查找相关知识，这些任务基本上都是基于这个指南的，下面是第一个问题的的例子： 12var header = document.querySelector(‘.text-branding’)header.innerText = ‘Boop&apos; 这个实验的主要目的是练习你所学的JavaScript和DOM之间的操作，并观察他们的行为。 实验2 使用CodePen写几个包含逻辑的JavaScript函数，以及操作DOM元素。这个实验的核心内容是将你从草根到英雄第一部分学到的知识和JavaScript结合，下面的几个例子可能会给你带来灵感： 周期表格 心情颜色产生器 计算器 JavaScript智力问答 小行星画布游戏 更多JavaScript目前你已经了解了一些JavaScript知识，并且为此做了一些练习，让我们继续学习一些高级的概念吧。下面的概念不一定互相有联系，我将它们列在这里是因为它们可以帮助你理解如何构建更复杂的前端系统。你将在后续的实验和框架章节理解如何使用这些概念。 语言一旦你用JavaScript工作，你将遇到很多高级概念，我将这些概念列出来，当你有时间时可以进行阅读。同样的，Eloquent JavaScript覆盖了大部分概念，也可以用来补充你的知识。 强化原型 作用域 闭包 事件循环 事件通知 请求、调用和绑定 回调和承诺 变量及函数挂起 Currying Imperative vs. DeclarativeJavaScript和DOM如何交互，有两种方法：imperative和declarative，一方面，declarative程序专注于what，另一方面，imperative程序专注于how 123456789var hero = document.querySelector(&apos;.hero&apos;)hero.addEventListener(‘click’, function() &#123; var newChild = document.createElement(‘p’) newChild.appendChild(document.createTextNode(‘Hello world!’)) newChild.setAttribute(‘class’, ‘text’) newChild.setAttribute(‘data-info’, ‘header’) hero.appendChild(newChild) &#125;)&#125; 上面是一个imperative程序的列子，我们手动查询出一个元素，并且将UI状态存储在里面，换句话说，该程序核心在于如何(how)完成某件事情。这段程序的最大问题是它不够稳定：如果某个人修改了这段代码中的类名，例如将hero修改为villain，该监听事件将不会被触发，因为DOM中不在有hero类了。 Declarative程序解决了这个问题，你可以把选择元素的操作留给框架或库去完成。这种做法让你专注于做什么(what)而不是如何这样做(how)。想要了解更多，读一下JavaScript的状态——从Imperative到Declarative和3D Web 开发 #1: Declarative vs. Imperative 这篇指南首先告诉你imperative方法，然后才是Angular和React库的declarative方法，我建议按照这样的顺序学习，可以让你更清楚的了解到declarative解决了什么问题。 Ajax通过以上的文章和指南，你应该注意到了Ajax，Ajax是一项可以使用JavaScript和服务器交互的技术。 例如，当你在网页上提交一个表单，这个动作会将你的输入作为一个HTTP请求发送给服务器。当你在Twitter上发送一条微博，你的Twitter客户端发送了一条HTTP请求给Twitter的API服务器，并且使用服务器返回的数据更新页面。 你可以看下什么是Ajax获得更多Ajax的知识。如果你仍然不能完全理解AJAX的概念，看一下Explain it like i’m 5, what is Ajax，如果觉得还不够多，你可以读一读Eloquent JavaScript的HTTP章节。 今天为止，新的浏览器请求标准是Fetch，想要了解更多的Fetch的内容，可以读一下Dan Walsh的这篇文章，里面介绍了Fetch是如何工作的，以及如何使用它。你还可以在这篇文章中补充Fetch polyfill知识。 jQuery目前为止，你已经使用JavaScript对DOM做了很多操作了。事实是，已经有很多DOM操作的库，他们提供API来简化你的代码。 最流行的DOM操作库是jQuery，记住，jQuery是一个imperative库，它是在前端系统还没有今天这么复杂的时候开发的。今天，为了管理复杂的UI，我们会使用declarative框架和库，例如Angular和React。然而，我仍然建议你学习jQuery，因为作为一名前端工程师，你一定会在工作中遇到它的。 学习jQuery基础，可以看下jQuery学习中心，它会一步步的告诉你animations和事件处理这些重要的概念。如果你还想学习更多入门知识，你可以看下Codecademy的jQuery课程 记住，jQuery不是唯一的imperative DOM操作解决方案，PlainJS和You Might Not Need jQuery是两个很好的资源，他们会告诉你和jQuery一样的频繁使用的JavaScript函数。 ES5 vs. ES6另一个重要的概念是ECMAScript以及它和Javascript的关系。目前你将会碰到两个主要的标准：ES5和ES6。ES5和ES6是JavaScript使用的ECMAScript标准，你可以把他们作为JavaScript的版本来理解，最终的ES5草案拟于2009年，也是我们目前一直在使用的。 ES6，也叫ES2015，它是最新的标准，带来了一些新的诸如常量，类，和模板这样的语言特性。ES6带来了新的语言功能，但仍然在ES5的基础上定义语义。例如，ES6中的类仅仅是JavaScript原型继承的语法修饰。 有必要知道你今天看到的应用，要么使用ES5，要么使用ES6。ES5，ES6，ES2016，ES.Next: JavaScript版本到底怎么了和Dan Wahlins的ES6入门——下一代JavaScript是很好的ES6介绍。接着你可以在ES6功能列表查看ES5到ES6的变化。如果你还想了解更多，去Github代码库获得更多ES6功能信息。 更多练习恭喜你能够到达这里，目前你已经学了很多关于JavaScript的知识，下面我们做一些练习。 实验3 实验3集中于练习如何应用DOM操作和jQuery技能。在这个试验中，我们将学会一些结构化的方法，实验3会要求你克隆Flipboard的主页，Codecademy上有这个教程，你只需要一步步照做即可：用JavaScript与Flipboard的主页进行交互指南 在学这篇指南的时候，请把注意力集中在理解如何与网站交互上，当实现了交互之后，就知道如何应用jQuery了。 实验4 实验4用介绍性的JavaScript课程将你所学的HTML和CSS结合起来。在这个试验中，你将创建一个你自己设计的时钟，并使用JavaScript让它具有交互性。开始之前，我建议你读一下HTML，CSS和JavaScript解耦这篇文章，你将从中学到当JavaScript引进时，CSS的基本类命名规范。下面，我依然从CodePen中挑选了一个列表，作为这个实验的参考。例如，你可以在CodePen中搜索一个时钟 扁平时钟 jQuery墙钟 漂亮的时钟 复古的时钟 JavaScript简单时钟 你可以使用两种方法来做这个实验，第一个是先创建和设计HTML、CSS布局，然后再增加JavaScript交互。第二个方法是先写JavaScript逻辑，然后把布局加进去。毫无疑问你可以使用jQuery，也可以自由使用原生的JavaScript。 JavaScript框架当你掌握了JavaScript基础之后，后续你需要了解一下JavaScript框架，框架是可以帮助你结构化和组织代码的JavaScript库，JavaScript框架是可复用的，并能提供解决复杂前端问题的方案，就像状态机，路由机制以及性能优化。他们被普遍用来创建web应用 我没有挨个的描述每个JavaScript框架，然而，这里有一些框架的链接：Angular，React + Flux，Ember，Aurelia，Vue，和Meteor。你不需要学习所有的框架，选一个学习即可，不要追赶框架的潮流，取而代之的是，你需要理解框架程序底下的原则和哲学。 架构模型在学习框架之前，了解一些框架经常用到的架构模型非常重要：model-view-controller，model-view-viewmodel，和model-view-presenter。这些模型被设计用来在应用程序的不同层次创建清晰而分离的特性. 分离的特性是一种建议将应用程序划分为不同的层次的设计原则。例如，与其让HTML保留应用状态，还不如用一个JavaScript对象——通常被称为Model——来存储状态。 要了解更多模型，首先阅读Chrome Developers中的MVC，然后，读一下理解MVC和MVP(献给JavaScript和主干开发者)，在这篇文章中，不用学习’主干’，仅仅了解MVC和MVP即可 对于MVVM，Addy Osman也写了篇文章：理解MVVM——给JavaScript开发者的指南， Martin Fowler的散文GUI 架构你也应该读读，它既讲了原生的MVC，又描述了MVVM是怎么来的。最终，读下这篇JavaScript MV* 模型，还有一本完美的免费在线书籍Learning JavaScript Design Patterns你也可以看下。 设计模式JavaScript 框架没有重复发明轮子，很多框架都依赖于设计模式，在软件开发过程中，你可以把设计模式想象成解决通用问题的模板。 然而学习设计模式不是理解JavaScript的必要条件，我建议你了解以下几个设计模式 装饰者模式 工厂模式 单件模式 Revealing module 外观模式 观察者模式 理解并实现一些设计模式不仅仅让你成为一个更好的工程师，还帮助你理解一些框架的具体实现。 AngularJSAngularJS是一个JavaScript MVC框架，有时也是一个MVVM框架，它由google维护，并在2010年初次发布时给JavaScript社区带来了一场风暴 Angular是一个declarative框架，对我帮助最大、帮我理解JavaScript编程是如何从imperative转换到declarativ思想的文章是来自StackOverflow的这篇文章：AngularJS和jQuery有哪些不同 想更多的了解Angular，可以查看Angular文档，里面还有一个Angular Cat项目，可以帮你马上进入编码状态。更完整的学习AngularJs指南可以在Tim Jacobi的Github仓库中查找。最后，你还可以看一下John Papa写的这篇权威的best practice styleguide React + FluxAngular很好解决了程序员在构建复杂系统时所面对的问题，另一个流行的工具是React，它是一个创建用户接口的库，你可以把它想象成MVC中的V。由于React只是一个库，所以它会经常伴随着一个框架Flux Facebook设计React和Flux的目的是为了解决MVC本身的不足和其扩展问题。先看一下他们总所周知的介绍：Hacker Way: Rethinking Web App Development at Facebook，它重温了Flux的历史。 搭梯子才能看的视频 React和Flux的学习，先从React开始，React文档是一个很好的入门教材。然后，这篇React.js Introduction For People Who Know Just Enough jQuery To Get By会帮助你扭转jQuery思维模式。 一旦你拥有了React基础，便可可以开始学习Flux，同样的，官方文档是一个很好的开端，继而，你可以看下极好的React，这篇文章可以带领你进入更深入的学习。 练习使用框架你现在拥有JavaScript框架和架构的基础知识，于是又到了练习的时候了。在后续两个实验中，专注于应用你学过的框架的概念。特别需要注意的是，你要让你的代码保持DRY原则，头脑中能清晰的理解不同的概念，并能够让你的模块仅完成单一的功能 实验5实验5的课题是将一个用JavaScript实现的TodoMVC的app掰开，然后再用将其重写。换句话说，这是一个没有任何框架的实验，但用到了MVC的原理，目的就是让你更深入的理解MVC是如何工作的。 首先你看一下TodoMVC长什么样子，然后你要做的是先创建一个新的本地工程，建立MVC的三个组件。你还需要拉取Github仓库上的代码，因为这是一个比较复杂的实验，如果你仍然无法完成克隆这个项目，抑或没有时间，没有关系，直接使用你下载的Github代码，不断调试MVC的不同组件，直到你理解了组件之间是如何运作的。 实验6实验6是一个应用MVC的很好练习，理解MVC是进入JavaScript框架的必经之路，实验6会让你跟着Scotch.io制作的指南，使用Angular建立一个Etsy页面的克隆版。 Build an Etsy Clone with Angular and Stamplay教你使用Angular创建一个web应用、API接口，以及如何组织大型的项目。完成了这个指南，试着回答以下几个问题： 什么是web应用？ Angulars是如何应用MVC/MVVM模型的？ 什么是API？它是用来做什么的？ 你如何组织大型的代码的？ 把UI打散到不同的组件的好处是什么？ 如果你想亲手创建更多的Angular web应用，试一下Build a Real-Time Status Update App with AngularJS &amp; Firebase。 实验7 现在你已经适应了MVC，轮到Flux上场了，实验7正是让你使用React和Flux框架创建一个todo列表。全过程在这里：Facebook的Flux文档，它会一步步教你如何使用React创建接口，以及Flux如何建立web应用。 一旦你全部完成，你可以进入更复杂的教程：如何使用React，Redux和Immutable.js创建一个Todo应用，并使用Flux和React建立一个微博应用 保持更新和其他前端开发一样，JavaScript的技术发展的很快，时刻保持更新这件事变得非常重要。 给出以下列表的网站，博客以及论坛，它们既有意思，又很有价值： Smashing Magazine JavaScript Weekly Ng Weekly Reddit JavaScript JavaScript Jabber 从例子中学习最佳的学习方式是从例子中学习 风格指南JavaScript风格指南是一组代码规范，它会帮助你设计具有可读性和可维护性高的代码。 AirBnB的编码规范 常用的JavaScript原则 Node编码规范 MDN编码规范 编码基础我已经无法形容读好代码给我带来的帮助到底有多大，一旦当你想读新的好代码时，可以上Github上找 Lodash Underscore Babel Ghost NodeBB KeystoneJS 圆满文章的结束，你应该稳固的掌握了JavaScript的基础，并且知道如何应用于Web开发。记住，这篇文章只是你的一个线路图，如果你想成为一个前端英雄，你还需要在项目中花更多的时间来适应这些概念，项目做得越多，你对他们也会越热情，你学到的也越多。 这篇文章是两部系列的第二部分，唯一遗漏的地方是Node，他是一个可以允许JavaScript运行在服务器上的框架，将来，也许我会在写一篇文章介绍Node相关的服务端开发，以及NoSql数据库 欢迎来Tweet上找我 作者：@Jonathan Z. White译者：jieniu原文：From Zero to Front-end Hero (Part 2)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端开发，从草根到英雄（第一部分）]]></title>
      <url>%2F2016%2F11%2F11%2Fzero-hero%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 我还记得当我刚开始学习前端开发时，我被大量的技术文章淹没，当时让我非常困惑的是：我究竟需要学多少知识才算足够，我甚至不知道从哪里开始。 这篇指南会告诉你学习前端开发的方向，它会提供一些过去我在学习中遇到的非常有效的学习资源，并伴随着我的一些注解。 为了让这篇指南更容易消化，我将它分成了两部分，第一部分主要讲HTML和CSS的开发接口，第二部分主要讲Javascript，框架，以及设计模式，如果你对HTML和CSS很熟悉，你可以直接跳到第二部分，那里全都是Javascript。 HTML和CSS基础在前端开发中，所有事物都以HTML和CSS开始，HTML和CSS控制了你在网页上看到的内容，HTML负责网页内容，而CSS负责样式和布局。 开始前，读一读Mozilla开发网（MDN）上的HTML和CSS入门，MDN将会讲解HTML和CSS中重要的概念，另外，每章节仅仅只有一张纸那么长，另外它还提供交互页面的链接（CodePen和JSFiddle）帮助你学习。 完成这些入门教程后，可以学下CodeAcademy的课程Make a Website。完成这篇教程只需要几个小时，它是使用HTML和CSS构建网站很好的入门教程，如果你停不下来，CodeAcademy还提供了另一个入门教程Building web forms，可以帮助你创建一个带有样式的表单。 如果想要做一些CSS的练习，试试CSS Diner，它是一个有趣的CSS挑战游戏，另外一个重要的HTML和CSS概念是布局，LearnLayout是一个教你如何使用HTML和CSS创建布局的交互式教程。 同样的，要学会利用Google字体API使用Google字体的CSS技巧，Typography是一个排版组织（block of interfaces），如果你有时间，我强烈建议你读一读这本免费的在线书籍Professional Web Typography，作者是Donny Truong，你将学到作为前端工程师所需要了解的所有排版知识。 通过这些资源后，不要担心自己记不住，而是将你的注意力集中在HTML和CSS在一起是如何工作的。 HTML和CSS基础练习目前你对HTML和CSS有了基本的认识，接下来我们玩点更有趣的。这一章节里，会有两个实验，它们会教你如何创建网站和接口。我用“实验”这个词的目的是：在实验中，你从失败中学到的东西将会和你从成功中学到的一样多 实验1第一个试验中，我们将学习使用CodePen。CodePen是一个前端编辑网站，在那里，你无需本地保存文件，就可以写HTML和CSS代码。当你保存代码的同时，你便可以进行在线预览。 CodePen是一个一石二鸟的工具，一方面，他可以帮助你练习HTML和CSS编程，另一方面，你创建了一个可以跟踪你进步的文件夹。我们还将使用Dribbble，这个网站充满了设计灵感。 进入Dribbble网站，选择一些在几个小时就可以完成的设计，我替你选了几个帮助你开始：1，2，3，4和5，首先从移动页面设计开始，因为我觉得它们比pc端页面简单，当然，也不用担心pc端页面设计会很难。 当你开始动手时，尝试在CodePen中写代码，如果你卡住了，记住StackOverflow是你的朋友，另一种非常有价值的练习则是登录像Medium，AirBnB或Dropbox这样的网站，使用Chome中的检查工具查看这些页面是如何实现不同的布局和样式的。然后，仔细研究CodePen中的部分画笔，同样，我也挑选了几个不错的链接： Menu App Interface Twitter Widget Article News Card Simple Flat Menu 如果你的“复制品”看起来和“参照物”不太一样，你也不必灰心，继续做不同的设计练习，你会发现每次你都会进步。 如果你没有任何设计背景，说明你的设计之眼没有被开发出来，一个拥有设计之眼的前端开发工程师能够很容易分辨好的设计并有能力将其完美复制出来。前不久我写了一篇关于如何开发设计之眼的文章。 实验2希望第一个实验能给你带来一些HTML和CSS的信心。在第2个实验中，我们将看一些网站，然后试图实现它们的组件。 一些网站会使用CSS框架，或重命名它们的CSS类名，这样的代码读起来非常困难，所以我挑选了一些源代码很好读的网站，这些网站拥有良好的设计。 Dropbox for Business: 试着复制hero段落 AirBnB: 试着复制页脚段落 PayPal: 试着复制导航条 Invision: 试着复制页面底部的登录部分 Stripe: 试着复制支付部分 同样的，第2个实验的重点也不是重建整个页面。选择一些像导航条或hero段落这样的关键组件去编码，对于做什么组件，我已经在网站列表右边给出了建议。 你可以在CodePen中做这些实验或者在本地操作，如果你选择将其存放在本地，你可以选择把这个例子工程作为模板下载下来，或者手动抓取这些文件。我建议你使用Atom或Sublime编辑器 同时，请记住在任何页面，你都可以看见它的HTML和CSS代码，仅仅只需要右键页面或页面中的一个组件，点击检查，一个HTML在左、CSS在右的面板便会弹出，一旦你完成了或卡住了，也可以使用检查器对你的HTML和CSS进行对照。 HTML、CSS最佳练习到目前为止，我们学到了基本的HTML和CSS，下面我们将要进入最佳练习，最佳练习指的是一些能帮助你提升代码质量的非常规规则。 语义标记如何写语义标签是HTML和CSS的最佳实践之一，好的语义意味着使用合适的HTML标签以及有意义的CSS类名，它们可以传达结构的含义。 例如，h1标签标记的文字代表它们是很重要的标题，再如footer标签，同样告诉我们这部分元素属于页面的底部。更进一步，建议你读一下A Look Into Proper HTML5 Semantics以及关于CSS技巧的文章：What Makes For a Semantic Class Name CSS命名约定另一个重要的最佳实践则是CSS命名约定，像语义标签一样，好的命名约定，会传达出有意义的内容、使我们的代码具有可预见性、可读以及可维护。你可以读一读这篇文章，讲的是不同的命名约定: OOCSS, ACSS, BEM, SMACSS: What are they? What should I use? 我还建议你尝试使用简单的命名约定以培养你对它们的直觉感受，因为随着时间推移，你将探索出那些最适合你的工作方式。想知道Medium这类公司是如何利用BEM这一的命名约定的，可以读下Medium’s CSS is actually pretty f*ing good。在那篇文章中，你将了解到创建一组高效的CSS语法是一个逐步迭代的过程。 CSS重置从边缘到边框，浏览器具有较小的样式不一致性。因此，请务必重置CSS。MeyerWeb是一个流行的重置工具。 如果你想更深入，你可以阅读Create Your Own Simple Reset.css File 跨浏览器支持跨浏览器支持意味着您的代码需要支持最新的浏览器。 某些CSS属性（如转换）需要供应商前缀才能在不同的浏览器中正常工作。 您可以在这篇本章中了解有关供应商前缀的更多信息，CSS供应商前缀。 主要的代价是，您需要在多个浏览器（包括Chrome，Firefox和Safari）上测试您的网站。 CSS预处理器和后处理器自从90年代引入CSS以来，CSS已经走了很长的路。 由于UI系统变得越来越复杂，人们想出了被称为预处理器和后处理器的工具来管理复杂性。 CSS预处理器是CSS语言扩展，增加了诸如变量，多态和继承的特性（bells和whistles）。 两个主要的CSS预处理器是Sass和Less。 在2016年，Sass开始被更广泛地使用。 Bootstrap，流行的响应式CSS框架，也从Less切换到Sass。 此外，当大多数人谈论Sass时，他们实际上在谈论SCSS。 CSS后处理器支持在CSS被预处理器手写或编译后仍可更改。 例如，一些后处理器（如PostCSS）具有自动添加浏览器供应商前缀的插件。 当你第一次发现CSS预处理器和后处理器，它是会引诱你无处不在的使用它们。 但是，建议你从简单开始，只有在必要时才添加扩展，例如变量和多态。 我之前提到的文章——Medium’s CSS is actually pretty f*ing good——涵盖了在涉及到预处理器时，使用多少才是合适的相关内容。 网格系统和响应式网格系统帮助把CSS结构竖直的和水平的排列起来。 像Bootstrap，Skeleton和Foundation这样的网格框架提供了用于管理布局中的行和列的样式表。 虽然网格框架很有用，但了解网格如何工作也很重要。 了解CSS网格系统和不要对网络想多了是重要的概述。 网格系统的主要目的之一是为您的网站增加响应能力。 响应性意味着您的网站可以基于窗口宽度调整大小。多次响应是由CSS媒体查询实现的，CSS规则仅仅适应于特定的屏幕宽度。 您可以在媒体查询简介中了解有关媒体查询的详情。 另外，因为我们已经进入了移动互联网时代，请查看Mobile-First Media Queries简介。 练习HTML和CSS最佳实践现在你已经武装了最佳实践的武器，我们可以用它来做一些”军式演习”，下两个实验的目标是练习写干净整洁的代码，以及长期观察最佳实践对可维护性和可读性的影响。 实验3第三个实验是，挑选一个之前的实验，并使用学到的最佳实践方法来重构它，重构的意思是编辑你的代码，让它变得更容易读和减少它的复杂性。 最为一个前端开发者，能够有效的重构代码是一项重要的能力。写出高质量代码是一个不断迭代的过程。这篇CSS架构：重构你的CSS很好的讲述了如何开始重构你的代码。 当你在重构代码时，你需要问自己几个问题： 你的类名是否模糊不清？在六个月后吗，你还会记得这些类名的意思吗？ 你的HTML和CSS具有语义吗？当你在此审视你的代码时，你还能快速辨别结构和关系的意义吗？ 你还在一遍遍的使用十六进制颜色编码吗？难道使用Sass变量重构它们不会更能表达它们的意思吗？ 你的代码在Safari上是否和在Chrome上一样好呢？ 你可以把你的布局代码换成想Skeleton这样的网格系统吗？ 你经常用!important标签吗？你如何解决这个问题？ 实验4最后一个实验将告诉你如何使用你学到的最佳实践。 然而，最佳实践的效果往往不明显，直到您将它们应用到一个更大的项目。 对于最后一个实验，建立自己的文件夹网站。 作为前端，您的文件夹网站是您最重要的数字资产之一。文件夹是展示您的工作的网站。 更重要的是，这是一个持续的记录，可以帮助你跟踪你的进步和发展。所以即使你只有1或2件事可以展示，你也应该把它们放上去。 在开始之前，先学习一下Adham Dannaway的文章，我的（简单）工作流：设计开发一个文件夹网站。 如果你的文件夹刚开始并不完美，也没关系，随着时间推移，文件夹会迭代，最重要的是，你将使用你自己的技能来创造它。 保持更新虽然HTML和CSS不会马上过时，但保持最新的技术视野是一件很重要的事情。 下面的网站，博客以及论坛列表很有意思，也很有价值： CSSTricks Smashing Magazine Designer News Nettuts+ CSS Wizard 从例子中学习最后，最好的学习方式是从例子中学习， 这里有一套styleguides和代码约定，将教你如何成为一个更有效的前端。 Styleguides Web Styleguides是可以在网站上重复使用的CSS组件和模式的集合。从这些Styleguides中要注意的关键是，基于HTML和CSS组件的复用, 如何让你保持DRY原则。 Mapbox LonelyPlanet SalesForce MailChimp 代码约定代码约定被设计用来提高代码的可读性和可维护性。很多像CSS指南这样的页面是为了帮助你写出更好的HTML和CSS代码。另一些像Github内部CSS工具和指南这样的页面提供了高质量代码的示例 CSS指南 Github内部CSS工具和指南 AirBnb的CSS指南 圆满希望在本文结束时，你已经非常熟悉HTML和CSS了，并有一些项目在折腾了。 学习前端的最好方法是建立项目和实验。 记住，每个前端开发人员都必须从某处开始。 从今天开始比明天更好。 本文是两部分系列的第一部分。第二篇文章介绍了使用Javascript和JavaScript库/框架添加交互性。此外，如果你想要我详细说明任何事情或有任何问题，随时留言或Tweet给我。 原文：zero to front-end hero作者：Jonathan Z. White 翻译：jieniu]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何在iterm2中设置自动远程登录（附跳板机攻略）]]></title>
      <url>%2F2016%2F11%2F07%2Fitem2-autologin%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 这篇文章是自己在3年前写的，发现还没有过时，便再次发表在自己的网站上 最近在mac中折腾ssh自动登录的问题，不自动登录每次输入命令太痛苦了，采取的方案是expect脚本的方式，其实选择这种方案而不是在远程服务器上保存key的方式主要是因为公司限制了在跳板机上保存私有数据的权限，如果想了解如何不输入密码登录远程机器的原理，请看这篇博客 当然，OS X上的终端可以使用iterm2，这样配置后便利性不比$99的secureCRT差 一般情况首先介绍下不通过跳板机进行登录的方式，准备： 写一个expect脚本 1234567891011#!/usr/bin/expect set timeout 30 spawn ssh [lindex $argv 0]@[lindex $argv 1] expect &#123; &quot;(yes/no)?&quot; &#123;send &quot;yes\n&quot;;exp_continue&#125; &quot;password:&quot; &#123;send &quot;[lindex $argv 2]\n&quot;&#125; &#125; interact 该脚本比较简单，需要三个参数，第一个参数是远程用户名，第二个参数是远程地址，第三个参数是密码 将expect脚本copy到$PATH下（例如/usr/local/bin） 在iterm2中设置登录命令为1中的脚本，用command+o的方式呼出profiles，点击Edit Profiles，按照下图的方式配好后，双击可以图1中的列表即可自动登录 有跳板机情况俺(前)公司的跳板机策略如下，不同公司的环境不一样，也许某些同学可以进行参考 跳板机上不能存放任何文件，/tmp下可以方临时文件，每天会定时清掉 copy文件方向只能是local-&gt;跳板机-&gt;remote的方向，即local可以push/pull跳板机上的文件，跳板机可以push/pull远程上的文件 向跳板机登录前需要通过邮件/短信的方式获取passcode，这是除密码之外的额外的验证方式 其实跳板机的自动远程登录与非跳板机的差异在expect脚本的编写上，其他的照搬即可，直接把代码贴出来吧 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/expect# 参数1：远程host；参数2：远程password if &#123; $argc != 2 &#125; &#123; send_user &quot;Usage: host password\n&quot; exit&#125;set host [lindex $argv 0]set pw [lindex $argv 1]set TERMSERV yourjumpserver # 跳板机服务器set USER jumpserveruser # 用户名set PASSWORD jumperserverpasswd # 跳板机密码set fd [open /place/to/passcode r] # 本地存放passcode的地方gets $fd pcclose $fd# Start the sessioncatch &#123;spawn ssh -l $USER $TERMSERV&#125; # 登录跳板机# Loginexpect &quot;*assword:*&quot; &#123; send &quot;$PASSWORD\r&quot; &#125;expect &quot;*passcode:*&quot; &#123; send &quot;$pc\r&quot; &#125; #通过跳板机登录线上机器expect &quot;*hostname*&quot; &#123; send &quot;ssh -l $USER $host\r&quot; &#125; # hostname为你跳板机的名字expect &#123; &quot;(yes/no)?&quot; &#123;send &quot;yes\n&quot;;exp_continue&#125; &quot;*assword:*&quot; &#123;send &quot;$pw\n&quot;&#125;&#125;expect &quot;*$host*&quot; &#123; send &quot;cd ~\r&quot;; interact &#125; 问题解决1如果在使用过程中，碰到了连接远程机器非常慢的情况，一般是因为开启了ControlMaster ，它会复用ssh连接，可以看下这篇文章，如果不想复用，可以通过修改 ~/.ssh/config配置文件将其关闭：12#ControlMaster auto#ControlPath ~/.ssh/master-%r@%h:%p%r 2密码中一般有特殊字符，注意传参时需要在密码两边加上单引号 因为目前公司的生产环境和之前的又不一样，这个代码属于旧代码了，所以如果有朋友在使用过程中发现问题，请帮忙纠正，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我终于理解了这些前端开发工具，相信你也可以]]></title>
      <url>%2F2016%2F11%2F05%2Fjs-tools%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 即便像我这样非常有经验的开发者，对于一些前端开发工具，也会产生疑惑。解决办法是在概念层面上理解它们是如何工作的，以及如何共同工作的。 这篇文章是我个人对于前端开发工具的理解，抛开代码层面，我们从理念层面来谈它们是如何完成它们的工作的。 不要对新技术产生恐惧目前已经有太多的前端开发工具：Node, NPM, Grunt, Gulp, Bower, Webpack, Browserify, Yeoman, Brunch……很容易让人产生跟不上节奏的感觉。 关键点就是不要害怕，所有这些工具都是为了让你更高效而设计的。 要理解它们是什么，为什么用它们，怎么用它们，我们只需要理解以下几个概念。 概念#1——开发工具的核心作用“安装 vs.执行”开发工具做两件事： 安装 执行 当你碰到一个新的工具，第一个问题应该是：“这个工具想要帮我安装还是执行？”npm，Bower和Yeoman都属于“安装”工具，他们能把安装这件事做的很漂亮。他们可以安装前端库，例如Angular.js或React.js。它们可以在服务器上安装开发环境，它们可以安装测试库。他们甚至可以帮你安装其他的前端开发工具。 “什么是bower？” ”一个包管理器，用npm安装它。” “什么是npm？” “一个包管理器，你可以用brew安装它。” “什么是brew？”… ——@ddprrt 简短的说，它们可以安装你可以想象的和代码相关的东西。 Grunt，Webpack，Require.js，Brunch和Gulp都是“执行”工具，它们比安装工具更复杂。它们的目标是自动化web开发中的体力活和容易出错的任务。“执行”的事情往往被称作“任务”。 为了执行这些“任务”，需要使用它们各自生态系统中的包和插件。每个工具执行任务的方式有差别，它们不会做相同的事情。有些“执行”工具试图做你抛给它的所有事情，其他的专注于一件事，例如解决Javascript依赖（例如Browserify, Require.js） 有时，在同一个项目中，可能会使用好几个这样的工具。 这里有一个被“执行”工具自动化的任务列表： 在文件中替换一个文本字符串 创建文件夹，并将文件移入 一键执行单元测试 保存文件时刷新浏览器 合并所有Javascript为一个文件，所有CSS文件为一个文件 最小化我的Javascript和CSS文件 在html页面中修改&lt;script&gt;标签的位置 当你理解了工具的安装功能和执行功能，对它们进行分类也变得非常容易： 概念#2——Node和npm是所有开发工具的祖先Node和npm可以安装和执行所有这些开发工具，所以你的项目会有它们的身影。正因为这一点，大多数开发者在求助于其他工具前，都会尽可能的使用这两款工具。 Node和npm落到我们的二分归纳法中，Node是执行工具，而npm是安装工具。 npm可以安装像Angular.js或React.js之类的库。为了开发方便，它还可以安装一个服务器，从而在本地运行你的app。它甚至可以安装例如最小化你的代码的可执行工具。 另一方面，Node是“执行”工具，例如运行Javascript文件，服务器等等。 如果你刚开始学习，从Node+npm开始，建议你在这两个工具上多花一些时间。当你的项目大到一定程度，你会遇到Node和npm自动化的限制，那时你再考虑使用其他的开发工具。 概念#3——有一种构建意味着你的应用已经就绪开发者经常把Javascript文件和CSS文件分成很多个文件，这样可以让我们写出模块化的代码，并且每个文件只完成一件事。一个文件只做一件事可以减少你的认知负担（如果你认为多个文件比起一个大文件来说会让你更困惑，试图在一个5000行的源文件上工作，我想你很快会改变你的想法的🙃） 但是，当你的产品发布后，太多文件不是一个好事情，当一个用户访问你的网站，你的每一个文件都需要使用一个额外的HTTP请求，这会使你的网站加载速度变慢。 作为补救，你可以为你的应用做一次“构建”，它会将所有CSS文件合并为一个文件，对于JavaScript文件也一样。结果是，你把文件大小和文件数最小化后，用户拿到的就是优化过的文件了，要这样做，你需要用一个构建工具。 下图是一个开发中的应用代码截图，注意到它拥有5个&lt;script&gt;标签和3个&lt;link&gt;标签，如果你注意到左边，你可以看到DEVELOPMENT文件夹下有10个文件 同时下图是相同的应用，只不过被构建工具施展了“魔法”。 注意到我们是怎么只有一个&lt;script&gt;标签和一个&lt;link&gt;标签的？和之前DEVELOPMENT下有10个文件比起来，现在只有4个文件。 应用每行都是一样的，只不过我们将其压缩到一个优雅的小包里，我们称之为“build”。 既然这样做仅仅只会节省用户几十毫秒的加载页面时间，你可能会想知道这样做到底值不值。可以这样说，如果你的网站只为少数一些人提供服务，你不需要关心这件事。构建工程仅仅只适用于大流量的网站（或者那些被认为即将成为大流量的网站😎） 如果你刚刚学编程，或网站流量较小，这样做将不是太有价值。 概念#4——安装和执行的分界线比较模糊没有一个工具是只做一件事且其他工具做其他的事，他们都会拥有安装和执行功能。但是大多数情况是，一个工具更趋向于安装或更趋向于执行。 一个“安装”工具有时也会执行程序，npm经常这样做，npm也可以执行命令和脚本——不仅仅是安装文件。一种工具，就像Yeoman，在你的机器上安装预编译引用的应用，同时它也会按需动态生成新文件，这些工具模糊了安装和执行间的这条分界线。 概念#5——对于开发工具，没有唯一的组合在项目中使用哪些开发工具，完全取决于你自己。 你可以选择不使用任何工具，仅仅保证复制，粘贴、最小化、开启服务、以及其它相关操作能够高效运作即可。 或者你仅仅只是用Node和npm来完成这些工作。对于初学者来说可以满足，但是当你的工程增长到一定程度，你可能会感觉到体力劳动越来越多。 这时你或许可以选择Node及npm上游的几个工具。所以你可以把Node和npm作为你自己的核心，也许还可以加上Grunt+Bower或Webpack或Gulp+Bower。 使用Node+npm上面的几种组合中的一种或几种，可以让你的工程中的大部分任务自动化，代价是学习这些工具的学习曲线很陡峭。 概念#6——开发工具的学习曲线很陡峭，所以只需学习什么是必须的开发一个应用足够难，你可能会学习一门新语言或者一个新的框架，或者你有比较取巧的商业逻辑，而合并一个开发工具可能会把额外的一层错综复杂的事物加到你的项目中。问题就在于写开发工具相关的代码的人并不属于你的团队。 我的建议是只学习你需要在你工作中涉及到的部分，其他的不学。 最佳的学习新事物的办法是你有一个真实的任务去完成。例如，为了你的利益，不要学习Grunt怎么拷贝文件的。取而代之的是，直到你确切需要这样做的时候，再使用它来解决吧。 记住：早期就把问题复杂化将会让你变慢。 概念#7——所有的开发工具拥有共同的目标：通过将所有体力劳动自动化从而让你开心当你发挥了你的开发工具的所有潜能，我把这种状态称作“开发工具涅磬”。这是一种当你保存一个文件，或运行一个命令，于是大量的任务便会自动执行的状态。 如果你的工具仍然需要你手动移动文件，改变值，或者运行命令才能编译，那么你还没有达到“工具涅磬”的状态。 拥有开发工具的好处便是保存一个文件，可以引发你的应用的编译，并发送到浏览器从而刷新新的内容。这会显著的加速你的前端开发工作流。 所以如何衡量你该付出多少努力在配置和设置开发工具上？很简单：只到它所做的事情让你高兴为止。 概念#8——不只是你，很多人都觉得这些工具的文档很糟糕事实上，很多这些工具的文档都不足，经常让我们做一些基本的任务都变得很难。 预先定义好的文档非常之少，你会看到很多不同的操作都导致同样的错误——在StackOverflow上经常看到回答的是同一个问题。 即便文档少这件事非常厌烦，但这些工具仍然可以增强你的代码技巧，并实现了很多创造性的事情。 原文：https://medium.freecodecamp.com/making-sense-of-front-end-build-tools-3a1b3a87043b#.hpbycrwz3作者：@roneesh 翻译：jieniu]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[那些你不知道的，可以用Chrome's Developer Console完成的事]]></title>
      <url>%2F2016%2F10%2F06%2Fchrome-console%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 Chrome内嵌的开发者工具拥有很多特性，例如网页元素，网络，和安全。今天我们将全部注意力投入到它的JavaScript控制台。 我刚开始编程时，仅仅把JavaScript控制台当做服务器响应包的日志输出，或者输出变量的值。随后，在帮助文档的帮助下，我发现了控制台可以做的很多事情都是我未曾想象过的。 以下是非常有用的功能，如果你阅读这篇文章时使用的是Chrome浏览器，你甚至可以立即打开它的开发工具并尝试这些功能。 1. 选择DOM元素如果你对jQuery比较熟悉，你知道$(‘.class’)和$(‘#id’)是非常重要的，它们可以利用和DOM元素相关联的id或class对元素进行选择。 但是当你不在jQuery和DOM环境中时，你仍然可以利用开发者控制台并使用相同的功能操作DOM。 $(&#39;tagName&#39;)、$(&#39;.class&#39;)、$(&#39;#id&#39;)、$(&#39;.class #id&#39;)和document.querySelector(&#39;&#39;)等价，将返回所匹配元素列表的第一个元素。 你可以使用双美元符$$(&#39;tagName&#39;)或$$(&#39;.class&#39;)选择被匹配的所有DOM元素，这些元素将被放入一个数组中。更进一步，你可以通过指定数组中的一个下标从而选出其中特定元素。 例如，$$(&#39;.className&#39;)将返回包含类className的所有元素，$$(&#39;.className&#39;)[0]和$$(&#39;.className&#39;)[1]将分别返回其中的第一个和第二个元素。 2. 把你的浏览器变成一个编辑器是否可以在浏览器中编辑文字？这个问题你想过多少次？答案是可以。你可以把你的浏览器变成一个编辑器，你可以在任意DOM中增加或删除文字。 你不再需要在HTML文件中编辑这个元素了，相反的，打开开发者控制台，并输入以下命令： 1document.body.contentEditable=true 该命令将使页面可编辑，此时你几乎可以编辑DOM中的任何东西。 3. 查找DOM中和某个元素相关联的事件Debug时，你应该对查找DOM中和某个元素绑定的事件监听者感兴趣。开发者控制台让这件事变得简单。 getEventListeners($(&#39;selector&#39;))返回绑定在指定元素上的所有事件对象的一个数组，你可以展开该对象从而查看事件： 你可以输入以下命令，从而输出监听器上的特定事件： 1getEventListeners($(‘selector’)).eventName[0].listener 该操作将展示监听器上绑定的特定事件，这里eventName[0]是一个列有特定事件的事件数组，例如： 1getEventListeners($(‘firstName’)).click[0].listener …将展示与ID为&#39;firstName&#39;元素相关联的点击事件的监听者。 4. 监控事件当你想监控DOM中某个元素执行中的事件，你也可以在开发者控制台中完成。以下是不同的监控这些事件的命令： monitorEvents($(&#39;selector&#39;))：监控选择器指定元素所关联的所有事件，一旦事件触发，将日志记录到控制台。例如，monitorEvents($(&#39;#firstName&#39;))将记录绑定在ID为’firstName’的元素上的所有事件。 monitorEvents($(‘selector’),’eventName’)：将记录绑定在元素上的特定事件，你可以将事件名作为参数传递给该函数。例如，monitorEvents($(&#39;#firstName&#39;), &#39;click&#39;)将记录所有绑定在ID为’firstName’的元素上的点击事件。 monitorEvents($(‘selector’),[‘eventName1’,’eventName3&#39;,….])：该命令将记录多个事件，具体数量取决于你的需求。区别是需要传递一组事件字符串数组作为参数，而不是单个事件名。例如monitorEvents($(&#39;#firstName&#39;), [&#39;click&#39;, &#39;focus&#39;])将记录在ID为’firstName’元素上所绑定的点击和焦点事件。 unmonitorEvents($(‘selector’))：停止监控和记录控制台中的事件。 5. 查看某个代码块的执行时间console.time(&#39;labelName&#39;)是JavaScript console的基本函数，它接受一个标签名作为参数，并开始计时。对应的，console.timeEnd(&#39;labelName&#39;)是另一个基本函数，它同样接受标签名作为参数，并结束标签名对应的时间。 例如： 1234console.time('myTime'); //Starts the timer with label - myTimeconsole.timeEnd('mytime'); //Ends the timer with Label - myTime//Output: myTime:123.00 ms 上面代码的前两行将返回时间开始到时间结束之间的时间。 我们可以利用它来计算执行一段代码所消耗的时间。 例如，我们想知道执行一个循环所消耗的时间，可以这样做： 123456789console.time('myTime'); //Starts the timer with label - myTimefor(var i=0; i &lt; 100000; i++)&#123; 2+4+5;&#125;console.timeEnd('mytime'); //Ends the timer with Label - myTime//Output - myTime:12345.00 ms 6. 将变量的值排列到表格中假设我们有一个数组变量看起来像这样： 1var myArray=[&#123;a:1,b:2,c:3&#125;,&#123;a:1,b:2,c:3,d:4&#125;,&#123;k:11,f:22&#125;,&#123;a:1,b:2,c:3&#125;] 当我们在控制台敲入变量名，将会以数组对象的形式展示，这非常有帮助，你可以展开对象从而查看对象值。 但当属性数量增加时，是比较难理解的。因此，为了更清晰的展示变量数据，我们可以将它们放到表格中。 console.table(variableName)将变量及其属性以表格的结构展示。它们看起来像这样： 7. 检查DOM中的元素在控制台中，你可以直接检查某个元素 inspect($(&#39;selector&#39;))将监视被匹配的元素，这个元素会被列在Chrome Developer Tool是的Elements标签栏。例如inspect($(&#39;#firstName&#39;))将监视ID为’firstName’的元素；inspect($(&#39;a&#39;[3]))将监视DOM中第4个&lt;a&gt;元素 $0, $1, $2, 等等，可以帮你获取当前被监视的元素。例如$0返回最后一个被监视的元素，而$1返回倒数第二个。 8. 列出元素的属性如果你想列出元素所有的属性，你也可以直接在控制台完成。 dir($(&#39;selector&#39;))返回一个包含关联元素中所有属性的对象，你可以展开查看更多细节。 9. 重新获取上一次结果的值你可以把控制台当做一个计算器，当你这样做时，你可能需要在第二个算式中使用第一个算式的计算结果，以下是如何在内存中获取前一个计算结果的方式： 1$_ 类似这样： 12345678910111213142+3+49 //- The Answer of the SUM is 9$_9 // Gives the last Result$_ * $_81 // As the last Result was 9Math.sqrt($_)9 // As the last Result was 81$_9 // As the Last Result is 9 10. 清空控制台和内存如果你想清空控制台和它的内存，只需要输入： 1clear() 这里只是Chrome的Javascript控制台的部分例子，我希望这些小技巧可以让你的工作更高效。 原文：Things you probably didn’t know you could do with Chrome’s Developer Console作者：Swagat Kumar Swain 翻译：jieniu]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[群晖ds216j安装迅雷远程下载]]></title>
      <url>%2F2016%2F08%2F21%2Fthunder%2F</url>
      <content type="text"><![CDATA[版权申明：此文章首发于公众号程序员在深圳，搜索 studycode 即可关注本文无需授权即可转载，转载时请务必注明作者 618买了个群晖nas，本是用来存储相机中的照片，做一些多端数据同步，但发现日常使用频率并不多，于是便想方设法去提升它的使用频率，从而增加它的价值。 网上基本上都是采用docker来实现这个功能，无奈ds216j是32位的，无法安装docker，只能采用直接运行程序的方式，遂在网上找到了这个安装包，安装后，通过以下步骤，即可实现远程下载。 拷贝该安装包到nas上某个目录，例如/volume1/app目录下 解压安装包，你会得到以下文件 123456$ ls /volume1/app/etm_detmetc_monitorlog.inithunder_mounts.cfgvod_httpserver 更改以下目录的读写权限 123$ sudo chmod 777 /volume1$ sudo chmod 777 /volume1/TDDOWNLOAD$ sudo chmod 777 /volume1/ThunderDB 运行etm_monitor，启动下载程序 1$ sudo nohup ./etm_monitor &amp; 运行成功后，可以通过ps命令查看进程状态 12345$ ps -ef | grep etmroot 15392 30988 0 13:56 pts/8 00:00:00 sudo nohup ./etm_monitorroot 15393 15392 0 13:56 pts/8 00:00:00 /bin/sh +x ./etm_monitorroot 15402 1 0 13:56 pts/8 00:00:00 ./etm --system_path=. --disk_cfg=./thunder_mounts.cfg --etm_cfg=./etm.ini --log_cfg=./log.ini --pid_file=./xunlei.pid --license=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx --hubble_report_pipe_path=/tmp/etm_hubble_report.pipe --ntfs_type=0 --listen_addr=0.0.0.0:9000root 15404 1 0 13:56 pts/8 00:00:00 ./vod_httpserver --etm_port=9000 剩下一步，就是打开浏览器，通过你的账号绑定迅雷下载器，这样你就可以利用浏览器对下载器创建下载任务了，在浏览器中输入host:9000/getsysinfo，host是nas的地址，通常是192.168.1.7，通过浏览器显示字符串获得激活码 1[0,1,1,0,&quot;wzjgjz&quot;,1,&quot;3.947.2.253_30&quot;,&quot;&quot;,1,&quot;0&quot;,0] 其中wzjgjz就是激活码，打开远程下载页面，登录，将激活码填入绑定则可以上是在ds216j上安装远程下载的完整过程，之后便可愉快在利用机器下片子了，最后贴一张热乎的使用图片，效果杠杠的 本文为原创内容，如需转载，请附上原始链接http://www.jianshu.com/p/1c06cdd58be6]]></content>
    </entry>

    
  
  
</search>
